{
  "id": "snapshot_1765128577430_esg59orcm",
  "approvalId": "approval_1765128166107_9qrcts1ac",
  "approvalTitle": "Design Document for Template Agent Enhancements",
  "version": 2,
  "timestamp": "2025-12-07T17:29:37.430Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Design Document\r\n\r\n## Overview\r\n\r\nThis design document outlines the technical architecture for enhancing `template-agent-typescript` with four major capabilities:\r\n\r\n1. **Multi-LLM Provider System**: Pluggable provider architecture supporting Anthropic Claude and OpenAI-compatible Model Manager Gateway\r\n2. **Autonomous Infrastructure Management**: Self-deployment capabilities using deploy-ability library to Digital Ocean\r\n3. **Persistent Memory System**: Multi-layered memory architecture (private/public × short-term/long-term) using ArcadeDB\r\n4. **Comprehensive File Management**: Integration of four file management abilities via KADI MCP protocol\r\n\r\nThe design follows a modular, service-oriented architecture where each capability is implemented as an independent service with clean interfaces, enabling the agent to function even if specific subsystems fail (graceful degradation).\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\n\r\n**Not applicable** - No steering documents exist for this project. The design follows KADI ecosystem patterns:\r\n\r\n- **MCP Protocol Integration**: File abilities accessed via KADI broker MCP protocol, not direct imports\r\n- **Result Type Pattern**: All async operations return `Result<T, E>` for predictable error handling\r\n- **Service Layer Architecture**: Clear separation between provider adapters, memory services, and bot logic\r\n- **Event-Driven Communication**: KADI events for bot mentions, tool invocations, and system notifications\r\n\r\n### Project Structure (structure.md)\r\n\r\n**Not applicable** - No steering documents exist. The design extends the existing template structure:\r\n\r\n```\r\ntemplate-agent-typescript/\r\n├── src/\r\n│   ├── index.ts                    # Main entry point (existing)\r\n│   ├── providers/                  # NEW: LLM provider system\r\n│   │   ├── base-provider.ts        # Provider interface\r\n│   │   ├── anthropic-provider.ts   # Existing Anthropic integration\r\n│   │   ├── model-manager-provider.ts # NEW: OpenAI-compatible gateway\r\n│   │   └── provider-manager.ts     # Provider orchestration & fallback\r\n│   ├── memory/                     # NEW: Memory system\r\n│   │   ├── memory-service.ts       # Core memory service\r\n│   │   ├── arcadedb-adapter.ts     # ArcadeDB integration\r\n│   │   └── types.ts                # Memory data models\r\n│   ├── deployment/                 # NEW: Self-deployment system\r\n│   │   ├── deploy-service.ts       # Deployment orchestration\r\n│   │   └── digital-ocean-config.ts # Deployment configuration\r\n│   ├── bot/                        # Existing bot implementations\r\n│   │   ├── slack-bot.ts            # Enhanced with memory & multi-LLM\r\n│   │   └── discord-bot.ts          # Enhanced with memory & multi-LLM\r\n│   └── tools/                      # Existing KADI tools\r\n├── .env                            # Configuration (enhanced)\r\n└── package.json                    # Dependencies (enhanced)\r\n```\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n- **KadiClient**: Broker connection, tool registration, event pub/sub\r\n  - *How it will be used*: Access file management abilities via `client.load()` and `protocol.invokeTool()`\r\n  - *Location*: `@kadi.build/core`\r\n\r\n- **BaseBot**: Circuit breaker, retry logic, metrics collection, tool discovery\r\n  - *How it will be used*: Extended by SlackBot and DiscordBot, provides resilience patterns\r\n  - *Location*: `shared/agents-library/src/base-bot.ts`\r\n\r\n- **ConversationManager**: Claude API multi-turn conversation handling\r\n  - *How it will be extended*: Add provider selection logic, route to Anthropic or Model Manager\r\n  - *Location*: `shared/agents-library/src/conversation-manager.ts`\r\n\r\n- **ToolExecutor**: KADI tool execution with retry and error handling\r\n  - *How it will be used*: Execute file operations through broker MCP protocol\r\n  - *Location*: `shared/agents-library/src/tool-executor.ts`\r\n\r\n- **Anthropic SDK Integration**: Currently hardcoded in index.ts (lines 208-229)\r\n  - *How it will be refactored*: Extract to `AnthropicProvider` class implementing `LLMProvider` interface\r\n\r\n### Integration Points\r\n\r\n- **KADI Broker MCP Protocol**: File abilities accessed via broker, not direct package imports\r\n  - *Integration*: Use `client.getBrokerProtocol().invokeTool()` pattern already established in index.ts (lines 310-318)\r\n\r\n- **Environment Variables**: Extend existing configuration in `.env`\r\n  - *Integration*: Add `MODEL_MANAGER_BASE_URL`, `MODEL_MANAGER_API_KEY`, `ARCADEDB_URL` to existing config\r\n\r\n- **Slack/Discord Bot Event Handlers**: Enhance existing bot implementations\r\n  - *Integration*: Inject MemoryService and ProviderManager into bot constructors\r\n\r\n## Architecture\r\n\r\n### High-Level System Architecture\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"User Interfaces\"\r\n        Slack[Slack Messages]\r\n        Discord[Discord Messages]\r\n    end\r\n\r\n    subgraph \"Bot Layer\"\r\n        SlackBot[SlackBot]\r\n        DiscordBot[DiscordBot]\r\n    end\r\n\r\n    subgraph \"Intelligence Layer\"\r\n        PM[ProviderManager]\r\n        AP[AnthropicProvider]\r\n        MMP[ModelManagerProvider]\r\n    end\r\n\r\n    subgraph \"Memory Layer\"\r\n        MS[MemoryService]\r\n        ADB[(ArcadeDB)]\r\n    end\r\n\r\n    subgraph \"File Operations Layer\"\r\n        FM[File Manager Proxy]\r\n        LRFM[local-remote-file-manager]\r\n        CFM[cloud-file-manager]\r\n        CRA[container-registry]\r\n        FMA[file-management]\r\n    end\r\n\r\n    subgraph \"Deployment Layer\"\r\n        DS[DeployService]\r\n        DA[deploy-ability]\r\n        DO[Digital Ocean]\r\n    end\r\n\r\n    Slack --> SlackBot\r\n    Discord --> DiscordBot\r\n    SlackBot --> PM\r\n    DiscordBot --> PM\r\n    SlackBot --> MS\r\n    DiscordBot --> MS\r\n    PM --> AP\r\n    PM --> MMP\r\n    MMP --> ModelManager[Model Manager Gateway]\r\n    MS --> ADB\r\n    SlackBot --> FM\r\n    DiscordBot --> FM\r\n    FM --> LRFM\r\n    FM --> CFM\r\n    FM --> CRA\r\n    FM --> FMA\r\n    DS --> DA\r\n    DA --> DO\r\n\r\n    style PM fill:#4A90E2\r\n    style MS fill:#9B59B6\r\n    style FM fill:#50C878\r\n    style DS fill:#FF6B6B\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n- **Single File Responsibility**: Each provider/service in separate file with single concern\r\n- **Component Isolation**: Memory, providers, deployment are independent modules with no cross-dependencies\r\n- **Service Layer Separation**:\r\n  - **Bot Layer**: Handles platform-specific events (Slack/Discord)\r\n  - **Intelligence Layer**: Routes LLM requests to appropriate provider\r\n  - **Memory Layer**: Persists and retrieves conversation context\r\n  - **Operations Layer**: File and deployment capabilities\r\n- **Utility Modularity**: Provider manager, memory service, deployment service are reusable across different bot implementations\r\n\r\n### Provider Selection Flow\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User\r\n    participant SlackBot\r\n    participant ProviderManager\r\n    participant AnthropicProvider\r\n    participant ModelManagerProvider\r\n    participant MemoryService\r\n\r\n    User->>SlackBot: \"@bot What is 2+2?\"\r\n    SlackBot->>MemoryService: retrieveContext(userId, channelId)\r\n    MemoryService-->>SlackBot: contextMessages[]\r\n    SlackBot->>ProviderManager: generateResponse(messages, model?)\r\n\r\n    alt model specified\r\n        ProviderManager->>ProviderManager: detectProvider(model)\r\n    else no model specified\r\n        ProviderManager->>ProviderManager: usePrimaryProvider()\r\n    end\r\n\r\n    alt Anthropic provider selected\r\n        ProviderManager->>AnthropicProvider: chat(messages)\r\n        AnthropicProvider-->>ProviderManager: response\r\n    else Model Manager provider selected\r\n        ProviderManager->>ModelManagerProvider: chat(messages)\r\n        ModelManagerProvider-->>ProviderManager: response\r\n    end\r\n\r\n    alt provider failed\r\n        ProviderManager->>ProviderManager: tryFallbackProvider()\r\n    end\r\n\r\n    ProviderManager-->>SlackBot: response\r\n    SlackBot->>MemoryService: storeMessage(userMsg, botMsg)\r\n    SlackBot-->>User: Response\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: LLMProvider Interface\r\n\r\n- **Purpose:** Define standard interface for all LLM provider adapters (Anthropic, Model Manager)\r\n- **Interfaces:**\r\n  ```typescript\r\n  interface LLMProvider {\r\n    name: string;\r\n    chat(messages: Message[], options?: ChatOptions): Promise<Result<string, ProviderError>>;\r\n    streamChat(messages: Message[], options?: ChatOptions): Promise<Result<AsyncIterator<string>, ProviderError>>;\r\n    isHealthy(): Promise<boolean>;\r\n    getAvailableModels(): Promise<Result<string[], ProviderError>>;\r\n  }\r\n\r\n  interface ChatOptions {\r\n    model?: string;\r\n    maxTokens?: number;\r\n    temperature?: number;\r\n    tools?: Tool[];\r\n  }\r\n\r\n  interface Message {\r\n    role: 'user' | 'assistant' | 'system';\r\n    content: string;\r\n  }\r\n\r\n  type Result<T, E> = { success: true; data: T } | { success: false; error: E };\r\n  ```\r\n- **Dependencies:** None (pure interface)\r\n- **Reuses:** None (new component)\r\n\r\n### Component 2: AnthropicProvider\r\n\r\n- **Purpose:** Adapter for Anthropic Claude API implementing LLMProvider interface\r\n- **Interfaces:** Implements `LLMProvider`\r\n- **Dependencies:** `@anthropic-ai/sdk`, environment variable `ANTHROPIC_API_KEY`\r\n- **Reuses:** Existing Anthropic SDK usage pattern from `index.ts` lines 208-229\r\n\r\n### Component 3: ModelManagerProvider\r\n\r\n- **Purpose:** Adapter for OpenAI-compatible Model Manager Gateway\r\n- **Interfaces:** Implements `LLMProvider`\r\n- **Dependencies:**\r\n  - Environment variables: `MODEL_MANAGER_BASE_URL`, `MODEL_MANAGER_API_KEY`\r\n  - HTTP client (fetch or axios)\r\n- **Reuses:** None (new component)\r\n- **Implementation Details:**\r\n  ```typescript\r\n  class ModelManagerProvider implements LLMProvider {\r\n    name = 'model-manager';\r\n    private baseURL: string;\r\n    private apiKey: string;\r\n\r\n    async chat(messages: Message[], options?: ChatOptions): Promise<Result<string, ProviderError>> {\r\n      const response = await fetch(`${this.baseURL}/v1/chat/completions`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${this.apiKey}`,\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          model: options?.model || 'gpt-4o-mini',\r\n          messages: messages.map(m => ({ role: m.role, content: m.content })),\r\n          max_tokens: options?.maxTokens,\r\n          temperature: options?.temperature,\r\n          tools: options?.tools\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        return { success: false, error: { code: response.status, message: await response.text() } };\r\n      }\r\n\r\n      const data = await response.json();\r\n      return { success: true, data: data.choices[0].message.content };\r\n    }\r\n  }\r\n  ```\r\n\r\n### Component 4: ProviderManager\r\n\r\n- **Purpose:** Orchestrate provider selection, health checking, and automatic fallback\r\n- **Interfaces:**\r\n  ```typescript\r\n  class ProviderManager {\r\n    constructor(providers: LLMProvider[], config: ProviderConfig);\r\n    async chat(messages: Message[], model?: string): Promise<Result<string, ProviderError>>;\r\n    async streamChat(messages: Message[], model?: string): Promise<Result<AsyncIterator<string>, ProviderError>>;\r\n    getHealthStatus(): Promise<Map<string, boolean>>;\r\n    private selectProvider(model?: string): LLMProvider;\r\n    private handleProviderFailure(provider: LLMProvider, error: ProviderError): Promise<Result<string, ProviderError>>;\r\n  }\r\n\r\n  interface ProviderConfig {\r\n    primaryProvider: string;      // 'anthropic' or 'model-manager'\r\n    fallbackProvider?: string;     // Optional fallback\r\n    retryAttempts: number;\r\n    retryDelayMs: number;\r\n    healthCheckIntervalMs: number;\r\n  }\r\n  ```\r\n- **Dependencies:** All registered `LLMProvider` implementations\r\n- **Reuses:** BaseBot's retry logic patterns\r\n\r\n### Component 5: MemoryService\r\n\r\n- **Purpose:** Multi-layered memory management with ArcadeDB persistence\r\n- **Interfaces:**\r\n  ```typescript\r\n  class MemoryService {\r\n    constructor(arcadedbUrl: string);\r\n\r\n    // Short-term memory (conversation context)\r\n    async storeMessage(userId: string, channelId: string, message: Message): Promise<Result<void, MemoryError>>;\r\n    async retrieveContext(userId: string, channelId: string, limit?: number): Promise<Result<Message[], MemoryError>>;\r\n\r\n    // Long-term memory (summarized history)\r\n    async summarizeAndArchive(userId: string, channelId: string): Promise<Result<void, MemoryError>>;\r\n    async searchLongTerm(userId: string, query: string): Promise<Result<MemoryEntry[], MemoryError>>;\r\n\r\n    // Private memory (user preferences)\r\n    async storePreference(userId: string, key: string, value: any): Promise<Result<void, MemoryError>>;\r\n    async getPreference(userId: string, key: string): Promise<Result<any, MemoryError>>;\r\n\r\n    // Public memory (shared knowledge)\r\n    async storeKnowledge(key: string, value: any): Promise<Result<void, MemoryError>>;\r\n    async getKnowledge(key: string): Promise<Result<any, MemoryError>>;\r\n  }\r\n\r\n  interface MemoryEntry {\r\n    id: string;\r\n    userId: string;\r\n    channelId?: string;\r\n    type: 'short-term' | 'long-term' | 'private' | 'public';\r\n    content: string;\r\n    metadata: Record<string, any>;\r\n    timestamp: Date;\r\n    relevanceScore?: number;\r\n  }\r\n  ```\r\n- **Dependencies:**\r\n  - `@kadi.build/arcadedb-ability`\r\n  - Environment variable: `ARCADEDB_URL`\r\n- **Reuses:** None (new component)\r\n\r\n### Component 6: ArcadeDBAdapter\r\n\r\n- **Purpose:** Low-level database operations for ArcadeDB\r\n- **Interfaces:**\r\n  ```typescript\r\n  class ArcadeDBAdapter {\r\n    constructor(dbUrl: string);\r\n    async connect(): Promise<Result<void, DatabaseError>>;\r\n    async disconnect(): Promise<Result<void, DatabaseError>>;\r\n    async query(cypher: string, params?: Record<string, any>): Promise<Result<any[], DatabaseError>>;\r\n    async createVertex(type: string, properties: Record<string, any>): Promise<Result<string, DatabaseError>>;\r\n    async createEdge(from: string, to: string, type: string, properties?: Record<string, any>): Promise<Result<void, DatabaseError>>;\r\n  }\r\n  ```\r\n- **Dependencies:** `@kadi.build/arcadedb-ability`\r\n- **Reuses:** None (new component)\r\n\r\n### Component 7: DeployService\r\n\r\n- **Purpose:** Self-deployment orchestration for Model Manager Gateway to Digital Ocean\r\n- **Interfaces:**\r\n  ```typescript\r\n  class DeployService {\r\n    constructor(config: DeployConfig);\r\n    async deployModelManager(): Promise<Result<DeploymentResult, DeployError>>;\r\n    async generateAPIKey(gatewayUrl: string, adminKey: string): Promise<Result<string, DeployError>>;\r\n    async registerOpenAIModels(gatewayUrl: string, adminKey: string, openaiKey: string): Promise<Result<string[], DeployError>>;\r\n    async updateAgentConfig(gatewayUrl: string, apiKey: string): Promise<Result<void, DeployError>>;\r\n  }\r\n\r\n  interface DeployConfig {\r\n    dropletRegion: string;          // 'nyc1', 'sfo3', etc.\r\n    dropletSize: string;            // 's-2vcpu-2gb'\r\n    containerImage: string;         // 'model-manager-agent:0.0.8'\r\n    adminKey: string;               // Admin key for gateway\r\n    openaiKey?: string;             // Optional for OpenAI model registration\r\n  }\r\n\r\n  interface DeploymentResult {\r\n    gatewayUrl: string;\r\n    apiKey: string;\r\n    deploymentId: string;\r\n    registeredModels: string[];\r\n  }\r\n  ```\r\n- **Dependencies:**\r\n  - `@kadi.build/deploy-ability`\r\n  - `@kadi.build/kadi-secret` (for storing generated API key)\r\n- **Reuses:** None (new component)\r\n\r\n### Component 8: FileManagerProxy\r\n\r\n- **Purpose:** Unified interface for accessing file management abilities via KADI broker\r\n- **Interfaces:**\r\n  ```typescript\r\n  class FileManagerProxy {\r\n    constructor(client: KadiClient);\r\n\r\n    // Local-Remote File Manager\r\n    async startFileServer(directory: string, port?: number): Promise<Result<FileServerInfo, FileError>>;\r\n    async stopFileServer(serverId: string): Promise<Result<void, FileError>>;\r\n\r\n    // Cloud File Manager\r\n    async uploadToCloud(provider: string, localPath: string, remotePath: string): Promise<Result<void, FileError>>;\r\n    async downloadFromCloud(provider: string, remotePath: string, localPath: string): Promise<Result<void, FileError>>;\r\n    async listCloudFiles(provider: string, path: string): Promise<Result<CloudFile[], FileError>>;\r\n\r\n    // Container Registry\r\n    async shareContainer(containerName: string): Promise<Result<ContainerRegistryInfo, FileError>>;\r\n    async stopRegistry(registryId: string): Promise<Result<void, FileError>>;\r\n\r\n    // SSH/SCP File Management\r\n    async uploadViaSSH(host: string, localPath: string, remotePath: string): Promise<Result<void, FileError>>;\r\n    async downloadViaSSH(host: string, remotePath: string, localPath: string): Promise<Result<void, FileError>>;\r\n    async executeRemoteCommand(host: string, command: string): Promise<Result<string, FileError>>;\r\n  }\r\n\r\n  interface FileServerInfo {\r\n    serverId: string;\r\n    localUrl: string;\r\n    tunnelUrl: string;\r\n  }\r\n\r\n  interface ContainerRegistryInfo {\r\n    registryId: string;\r\n    registryUrl: string;\r\n    loginCommand: string;\r\n    pullCommand: string;\r\n  }\r\n  ```\r\n- **Dependencies:**\r\n  - `KadiClient` for broker access\r\n  - File abilities accessed via `protocol.invokeTool()`, not direct imports\r\n- **Reuses:** Existing tool invocation pattern from `index.ts` lines 310-318\r\n\r\n## Data Models\r\n\r\n### Memory Data Models\r\n\r\n```typescript\r\n// Short-term memory (conversation context)\r\ninterface ConversationMessage {\r\n  id: string;\r\n  userId: string;\r\n  channelId: string;\r\n  role: 'user' | 'assistant';\r\n  content: string;\r\n  timestamp: Date;\r\n  metadata: {\r\n    platform: 'slack' | 'discord';\r\n    threadId?: string;\r\n  };\r\n}\r\n\r\n// Long-term memory (summarized conversations)\r\ninterface ConversationSummary {\r\n  id: string;\r\n  userId: string;\r\n  channelId: string;\r\n  summary: string;\r\n  messageCount: number;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  topics: string[];\r\n  relevanceScore: number;\r\n}\r\n\r\n// Private memory (user preferences)\r\ninterface UserPreference {\r\n  userId: string;\r\n  key: string;\r\n  value: any;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Public memory (shared knowledge)\r\ninterface PublicKnowledge {\r\n  key: string;\r\n  value: any;\r\n  source: string;\r\n  confidence: number;\r\n  createdAt: Date;\r\n  accessCount: number;\r\n}\r\n```\r\n\r\n### Provider Data Models\r\n\r\n```typescript\r\ninterface ProviderStatus {\r\n  name: string;\r\n  isHealthy: boolean;\r\n  lastHealthCheck: Date;\r\n  consecutiveFailures: number;\r\n  averageResponseTime: number;\r\n}\r\n\r\ninterface ProviderError {\r\n  code: string;               // 'AUTH_FAILED', 'RATE_LIMIT', 'TIMEOUT', etc.\r\n  message: string;\r\n  provider: string;\r\n  timestamp: Date;\r\n  retryable: boolean;\r\n}\r\n```\r\n\r\n### Deployment Data Models\r\n\r\n```typescript\r\ninterface DeploymentConfig {\r\n  platform: 'digital-ocean' | 'akash';\r\n  region: string;\r\n  resources: {\r\n    cpu: number;\r\n    memory: string;\r\n    storage: string;\r\n  };\r\n  containerImage: string;\r\n  environment: Record<string, string>;\r\n}\r\n\r\ninterface DeploymentStatus {\r\n  deploymentId: string;\r\n  status: 'pending' | 'deploying' | 'running' | 'failed' | 'stopped';\r\n  gatewayUrl?: string;\r\n  apiKey?: string;\r\n  createdAt: Date;\r\n  lastUpdated: Date;\r\n}\r\n```\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n1. **Provider Unavailable (Network/API Failure)**\r\n   - **Handling:** ProviderManager marks provider unhealthy, attempts fallback provider\r\n   - **User Impact:** \"Switching to backup AI provider...\" message shown if fallback succeeds\r\n   - **Code:** Return `{ success: false, error: { code: 'PROVIDER_UNAVAILABLE', retryable: true } }`\r\n\r\n2. **Authentication Failure (Invalid API Key)**\r\n   - **Handling:** ProviderManager marks provider unhealthy, logs error with obfuscated key\r\n   - **User Impact:** \"AI provider authentication failed. Please check configuration.\" message\r\n   - **Code:** Return `{ success: false, error: { code: 'AUTH_FAILED', retryable: false } }`\r\n\r\n3. **Rate Limit Exceeded**\r\n   - **Handling:** ProviderManager implements exponential backoff (5s, 10s, 20s), marks provider temporarily unavailable\r\n   - **User Impact:** \"AI provider is rate limited. Retrying in X seconds...\" message\r\n   - **Code:** Return `{ success: false, error: { code: 'RATE_LIMIT', retryable: true } }`\r\n\r\n4. **Memory Database Connection Lost**\r\n   - **Handling:** MemoryService attempts reconnection with exponential backoff, agent continues without memory\r\n   - **User Impact:** Warning logged, conversations proceed without context\r\n   - **Code:** Agent degrades gracefully, no user-facing error for non-critical memory failures\r\n\r\n5. **File Operation Failure (Permission Denied, Not Found)**\r\n   - **Handling:** FileManagerProxy returns detailed error with path and permission info\r\n   - **User Impact:** \"File operation failed: [specific error]. Check permissions and path.\"\r\n   - **Code:** Return `{ success: false, error: { code: 'FILE_ERROR', message: details } }`\r\n\r\n6. **Deployment Failure (Insufficient Resources, Invalid Config)**\r\n   - **Handling:** DeployService validates configuration before deployment, rolls back on failure\r\n   - **User Impact:** \"Deployment failed: [specific reason]. Rolled back successfully.\"\r\n   - **Code:** Return `{ success: false, error: { code: 'DEPLOY_FAILED', message: details } }`\r\n\r\n7. **All Providers Failed**\r\n   - **Handling:** ProviderManager returns aggregated error listing all provider failures\r\n   - **User Impact:** \"All AI providers unavailable. Please try again later. [Details: ...]\"\r\n   - **Code:** Return `{ success: false, error: { code: 'ALL_PROVIDERS_FAILED', providers: [...] } }`\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n- **Provider Tests**: Mock HTTP responses for Model Manager, test Anthropic provider with test keys\r\n- **Memory Tests**: Use in-memory ArcadeDB for unit tests, verify CRUD operations\r\n- **Provider Manager Tests**: Mock provider responses, test fallback logic with controlled failures\r\n- **File Proxy Tests**: Mock KADI protocol invocations, verify request formatting\r\n\r\n### Integration Testing\r\n\r\n- **End-to-End Provider Flow**: Real API calls to Model Manager test deployment and Anthropic with test keys\r\n- **Memory Persistence**: Use test ArcadeDB instance, verify data survives service restarts\r\n- **Deployment Flow**: Use Digital Ocean test droplet, verify full deployment cycle\r\n- **File Operations**: Use test directories and containers, verify tunnel creation and file transfers\r\n\r\n### End-to-End Testing\r\n\r\n- **Slack Bot with Multi-Provider**: Send test messages, verify provider switching and fallback\r\n- **Discord Bot with Memory**: Have conversation, restart bot, verify context restored\r\n- **Deployment Test**: Deploy Model Manager, generate API key, update agent config, make LLM request\r\n- **File Sharing Test**: Start file server, verify public URL accessible, upload to cloud storage\r\n",
  "fileStats": {
    "size": 23021,
    "lines": 601,
    "lastModified": "2025-12-07T17:22:38.946Z"
  },
  "comments": []
}