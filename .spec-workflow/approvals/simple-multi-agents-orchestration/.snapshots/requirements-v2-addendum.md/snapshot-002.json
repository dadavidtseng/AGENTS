{
  "id": "snapshot_1764500750795_kr1t9w9uk",
  "approvalId": "approval_1764498637884_jaszruh1w",
  "approvalTitle": "Requirements V2 Addendum - Architectural Corrections (Supersedes Original)",
  "version": 2,
  "timestamp": "2025-11-30T11:05:50.795Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements V2: Architectural Corrections Addendum\n\n**Spec Name:** `simple-multi-agents-orchestration`\n**Original Date:** 2025-11-30\n**Revision:** V2 - 2025-11-30\n**Status:** Draft - Pending Approval\n**Type:** Architectural Corrections Addendum\n\n---\n\n## Purpose of This Document\n\nThis addendum corrects the original requirements.md based on deep codebase analysis. All sections below SUPERSEDE the corresponding sections in the original requirements.md.\n\n**Key Changes:**\n1. Rename shrimp-AGENTS → **shrimp-agent-playground**\n2. Remove custom event publishing → Use **protocol.invokeTool()** via KĀDI broker\n3. Remove manual agent registry → Use **protocol.discoverAgents()**\n4. Remove custom heartbeats → Use **status polling** via shrimp__list_tasks\n5. Add **git worktree workspace isolation** strategy\n6. Add **BaseBot inheritance** for resilience patterns\n7. Add **MCP upstream configuration** requirements\n\n---\n\n## 1. Overview (SUPERSEDES Original Section 1)\n\n### 1.1 Purpose\nEnable agent-producer to act as an intelligent orchestrator that:\n- Receives user requests from multiple channels (Claude Desktop, Claude Code, Slack, Discord)\n- Breaks down work into structured tasks using **shrimp-agent-playground MCP server** (accessed via KĀDI broker as MCP upstream)\n- Creates isolated git worktrees for each worker agent before task assignment\n- Distributes tasks via **broker protocol tool invocation** (`protocol.invokeTool()`)\n- Monitors execution via **status polling** (shrimp__list_tasks every 30s)\n- Coordinates verification and user feedback\n\n### 1.2 Architecture Foundation\n\n**KĀDI Broker MCP Upstream Pattern:**\n```\nagent-producer → KĀDI broker → shrimp-agent-playground (MCP upstream)\n              ↓\n              → mcp-server-git (git worktree tools)\n              ↓\n              → mcp-server-slack (messaging tools)\n              ↓\n              → mcp-server-discord (messaging tools)\n              ↓\n              → worker agents (task execution tools)\n```\n\n**No Direct Connections:**\n- ❌ agent-producer does NOT connect directly to shrimp-agent-playground\n- ❌ agent-producer does NOT publish custom KĀDI events\n- ❌ agent-producer does NOT maintain manual agent registry\n- ✅ ALL communication via `protocol.invokeTool()` through broker\n\n### 1.3 Goals\n- **G1:** Automate project decomposition via shrimp-agent-playground MCP tools\n- **G2:** Enable concurrent task execution with git worktree workspace isolation\n- **G3:** Distribute tasks via broker protocol tool invocation (no custom events)\n- **G4:** Monitor execution via status polling (no heartbeat protocol)\n- **G5:** Inherit resilience patterns from BaseBot (circuit breaker, retry logic)\n- **G6:** Handle failures gracefully with automatic reassignment\n\n---\n\n## 2. Critical Architecture Changes (NEW SECTION)\n\n### 2.1 MCP Server Integration via Broker\n\n**Configuration File:** `kadi-broker/config/mcp-upstreams.json`\n\n**Required Entry:**\n```json\n{\n  \"upstreams\": [\n    {\n      \"id\": \"shrimp-agent-playground\",\n      \"name\": \"shrimp-agent-playground\",\n      \"description\": \"Task and spec management for agent playground\",\n      \"type\": \"stdio\",\n      \"prefix\": \"shrimp\",\n      \"enabled\": true,\n      \"stdio\": {\n        \"command\": \"node\",\n        \"args\": [\"C:/p4/Personal/SD/shrimp-agent-playground/dist/index.js\"],\n        \"env\": {\n          \"MCP_LOG_LEVEL\": \"info\"\n        }\n      },\n      \"networks\": [\"global\"],\n      \"retryPolicy\": {\n        \"maxAttempts\": 3,\n        \"initialBackoffMs\": 1000,\n        \"maxBackoffMs\": 10000,\n        \"backoffMultiplier\": 2\n      }\n    }\n  ]\n}\n```\n\n**Tool Invocation:**\n```typescript\n// Call shrimp-agent-playground tools via broker\nconst result = await this.invokeToolWithRetry({\n  targetAgent: 'shrimp-agent-playground',\n  toolName: 'shrimp__plan_task',\n  toolInput: { description: 'User request here...' },\n  timeout: 30000\n});\n```\n\n### 2.2 Git Worktree Workspace Strategy\n\n**Base Playground Directory:**\n```\nC:/p4/Personal/SD/agent-playground\n```\n\n**Worker Agent Worktrees:**\n```\nC:/p4/Personal/SD/agent-playground-artist\nC:/p4/Personal/SD/agent-playground-designer\nC:/p4/Personal/SD/agent-playground-programmer\n```\n\n**Workflow:**\n1. **Before Task Assignment:**\n   ```typescript\n   await this.invokeToolWithRetry({\n     targetAgent: 'mcp-server-git',\n     toolName: 'git__worktree',\n     toolInput: {\n       path: 'C:/p4/Personal/SD/agent-playground',\n       mode: 'add',\n       worktreePath: 'C:/p4/Personal/SD/agent-playground-artist',\n       branch: 'task-001',\n       commitish: 'main'\n     },\n     timeout: 10000\n   });\n   ```\n\n2. **During Task Assignment:**\n   ```typescript\n   await this.invokeToolWithRetry({\n     targetAgent: 'agent-artist',\n     toolName: 'execute_task',\n     toolInput: {\n       taskId: 'task-001',\n       workspace: {\n         worktreePath: 'C:/p4/Personal/SD/agent-playground-artist',\n         branch: 'task-001',\n         baseBranch: 'main'\n       }\n     },\n     timeout: 30000\n   });\n   ```\n\n3. **After Successful Completion:**\n   ```typescript\n   await this.invokeToolWithRetry({\n     targetAgent: 'mcp-server-git',\n     toolName: 'git__worktree',\n     toolInput: {\n       path: 'C:/p4/Personal/SD/agent-playground',\n       mode: 'remove',\n       worktreePath: 'C:/p4/Personal/SD/agent-playground-artist',\n       force: true\n     },\n     timeout: 10000\n   });\n   ```\n\n4. **After Failed Task:**\n   - **DO NOT cleanup worktree** (preserve for debugging)\n   - Log worktree path for manual investigation\n\n### 2.3 BaseBot Inheritance Pattern\n\n**Required Implementation:**\n```typescript\nimport { BaseBot, BaseBotConfig } from '@agents/shared';\nimport { KadiClient } from '@kadi.build/core';\n\nexport class ProducerAgent extends BaseBot {\n  constructor(config: BaseBotConfig) {\n    super(config);\n  }\n\n  async start(): Promise<void> {\n    // MUST call initializeProtocol() first\n    this.initializeProtocol();\n    \n    // Now can use inherited methods:\n    // - this.invokeToolWithRetry() - Automatic retry + circuit breaker\n    // - this.checkCircuitBreaker() - Check if circuit is open\n    // - this.getMetrics() - Get performance metrics\n    // - this.logMetrics() - Log current metrics\n    \n    // Subscribe to events if needed\n    this.client.subscribeToEvent('slack.app_mention.*', async (event) => {\n      await this.handleUserRequest(event);\n    });\n  }\n\n  async stop(): Promise<void> {\n    // Cleanup logic\n  }\n\n  protected async handleMention(event: any): Promise<void> {\n    // Implement from BaseBot abstract method\n  }\n}\n```\n\n**Inherited Capabilities:**\n- **Circuit Breaker:** Opens after 5 consecutive failures, resets after 60 seconds\n- **Retry Logic:** Exponential backoff (1s, 2s, 4s) up to 3 attempts\n- **Metrics Tracking:** Total requests, success count, timeout count, success rate, circuit breaker status\n- **Connection Recovery:** Handles broker disconnections gracefully\n\n### 2.4 Agent Discovery (NO Manual Registry)\n\n**Discovery via Broker:**\n```typescript\n// Get all connected agents with their tools\nconst agents = await this.protocol.discoverAgents();\n\n// Result structure:\n// [\n//   {\n//     agentId: \"agent-artist\",\n//     tools: [\n//       { name: \"create_design_doc\", description: \"...\" },\n//       { name: \"generate_wireframes\", description: \"...\" }\n//     ],\n//     networks: [\"global\", \"design\"]\n//   },\n//   {\n//     agentId: \"agent-programmer\",\n//     tools: [\n//       { name: \"implement_feature\", description: \"...\" },\n//       { name: \"write_tests\", description: \"...\" }\n//     ],\n//     networks: [\"global\", \"development\"]\n//   }\n// ]\n\n// Match task to agent based on tool names\nconst designTask = { requiredCapabilities: ['design', 'documentation'] };\nconst matchingAgent = agents.find(agent =>\n  agent.tools.some(tool => \n    tool.name.includes('design\n",
  "fileStats": {
    "size": 7781,
    "lines": 258,
    "lastModified": "2025-11-30T10:30:15.304Z"
  },
  "comments": []
}