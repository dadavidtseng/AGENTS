{
  "id": "snapshot_1766540383616_shthryvbh",
  "approvalId": "approval_1766540383600_xelg4v842",
  "approvalTitle": "Design Document for 7 KADI Abilities Integration",
  "version": 1,
  "timestamp": "2025-12-24T01:39:43.616Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design implements the integration of 7 existing KADI abilities into the template-agent-typescript codebase by replacing custom file management and deployment implementations with broker-mediated ability invocations. The integration follows the agent's existing architectural patterns (provider system, Result<T, E> error handling, service layer) while leveraging KADI's distributed service-oriented architecture.\n\nThe design transforms template-agent from a partially autonomous agent with custom I/O implementations into a pure orchestration agent that delegates all file operations, deployments, and infrastructure concerns to specialized KADI abilities.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**N/A** - No steering documents exist for this project. The design follows KADI architectural principles:\n- **Broker-mediated communication**: All tool invocations via JSON-RPC 2.0 over WebSocket\n- **Ed25519 authentication**: Zero-trust security for all broker connections\n- **Network isolation**: Tools visible only within shared networks\n- **Event-driven architecture**: Real-time progress updates via pub/sub\n\n### Project Structure (structure.md)\n\n**N/A** - No steering documents exist. The design follows template-agent's established patterns:\n- **Provider pattern**: Interface → Implementation → Manager (from `src/providers/`)\n- **Result<T, E> error handling**: Rust-inspired error handling (from `src/common/result.ts`)\n- **Service layer architecture**: High-level orchestration services (from `src/memory/memory-service.ts`)\n- **Tool registry pattern**: Extensible tool registration (from `src/tools/`)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **KadiClient** (`src/index.ts:127-133`): Already properly configured for broker connection\n  - Will be extended to load 7 abilities using `client.load(name, 'broker')`\n  - Current networks: ['global', 'slack', 'discord'] → extend to include 'file-ops', 'deployment', 'tunnel'\n\n- **Result<T, E> Type** (`src/common/result.ts`): Rust-inspired error handling\n  - Will be used for all ability wrapper methods\n  - Maintains consistency with existing codebase\n\n- **Protocol Invocation Pattern** (`src/index.ts:283-328`): Existing pattern for `protocol.invokeTool()`\n  - Example: fs_write_file invocation with timeout, target agent\n  - Will be wrapped in higher-level ability proxy methods\n\n- **Provider Manager Pattern** (`src/providers/provider-manager.ts:481 lines`):\n  - Health checks, retry logic, circuit breaker, automatic fallback\n  - Will inspire AbilityManager design for coordinating multiple abilities\n\n- **Error Classification** (`src/providers/anthropic-provider.ts:302-334`):\n  - Sophisticated error type detection (auth, rate limit, network, transient)\n  - Will be adapted for ability-specific error types\n\n- **Event Subscription** (`src/index.ts:174-188`): Existing pattern for subscribeToEvent()\n  - Will be extended to subscribe to ability progress events\n  - Example events: 'deploy.progress', 'file-manager.upload-progress', 'tunnel.created'\n\n### Integration Points\n\n- **KADI Broker Connection** (`src/index.ts:585`): `client.serve('broker')`\n  - Already established, no changes needed\n  - Abilities will connect to same broker instance\n\n- **Tool Registry** (`src/tools/index.ts:54-82`): Existing extensible registration pattern\n  - If agent needs to expose new tools that wrap abilities, use this pattern\n  - Current tools (echo, list_tools) will coexist with ability invocations\n\n- **Memory Service** (`src/memory/memory-service.ts:578 lines`): Graceful degradation pattern\n  - ArcadeDB adapter will remain for Cypher queries\n  - New arcadedb-ability will be used only for Docker operations (start/stop containers)\n  - Maintains hybrid architecture\n\n- **Bot Integration** (`src/bot/slack-bot.ts`, `src/bot/discord-bot.ts`):\n  - Bots already use `protocol.invokeTool()` pattern\n  - Will gain access to 7 new abilities for richer responses\n  - Example: File sharing via cloud-file-manager-ability\n\n### Files to Remove\n\n1. **`src/file-management/file-manager-proxy.ts`** (535 lines)\n   - Current methods: startFileServer, uploadToCloud, downloadFromCloud, uploadViaSSH, shareContainer\n   - Replacement: Direct invocation of file-management-ability, local-remote-file-manager-ability, cloud-file-manager-ability\n\n2. **`src/deployment/deploy-service.ts`** (422 lines)\n   - Current methods: deployModelManager, generateAPIKey, registerOpenAIModels\n   - Replacement: Direct invocation of deploy-ability tools\n\n3. **`src/deployment/types.ts`**\n   - Types moved to ability wrappers if needed\n\n4. **`test/deployment/`** - Deployment tests (will be replaced with E2E ability tests)\n\n5. **`test/file-management/`** - File management tests (will be replaced with E2E ability tests)\n\n## Architecture\n\nThe integration follows a **3-layer architecture**:\n\n### Layer 1: KADI Abilities (External Services)\n\n7 independent services running as separate processes, each with KadiClient:\n\n1. **kadi-tunnel-ability** - Self-hosted tunneling (Let's Encrypt SSL)\n2. **local-remote-file-manager-ability** - Local file ops + S3 serving + tunneling\n3. **arcadedb-ability** - Docker container management for ArcadeDB\n4. **cloud-file-manager-ability** - Dropbox/Drive/Box integration\n5. **container-registry-ability** - OCI registry operations\n6. **deploy-ability** - Akash/Docker deployment orchestration\n7. **file-management-ability** - SSH/SCP remote operations\n\nEach ability:\n- Connects to broker with `role: 'ability'`\n- Registers tools with MCP-compliant JSON schemas\n- Publishes progress events during long operations\n- Handles Ed25519 authentication automatically\n\n### Layer 2: Ability Proxy Wrappers (Agent-Side)\n\nOptional thin wrappers in agent for type safety and convenience:\n\n```\nsrc/abilities/\n├── ability-manager.ts      # Orchestrates loading, health checks, fallback\n├── types.ts                # Shared AbilityError, AbilityOptions types\n├── tunneling/\n│   ├── tunneling-proxy.ts  # Wrapper for kadi-tunnel + local-remote tunneling\n│   └── types.ts\n├── file-operations/\n│   ├── file-ops-proxy.ts   # Wrapper for file-management + local-remote + cloud\n│   └── types.ts\n├── deployment/\n│   ├── deployment-proxy.ts # Wrapper for deploy-ability\n│   └── types.ts\n├── database/\n│   ├── db-proxy.ts         # Wrapper for arcadedb-ability (Docker only)\n│   └── types.ts\n└── index.ts                # Barrel exports\n```\n\n### Layer 3: Agent Orchestration (High-Level Services)\n\nExisting services (memory, providers, bot, tools) use abilities via Layer 2 proxies:\n\n```typescript\n// Example: Bot using file-operations proxy\nconst fileOps = abilityManager.getFileOperations();\nconst uploadResult = await fileOps.uploadToCloud({\n  provider: 's3',\n  localPath: '/tmp/image.png',\n  remotePath: 's3://bucket/artwork.png'\n});\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each ability proxy handles one domain (files, deployment, tunneling)\n- **Component Isolation**: Proxies are independent, can be used individually\n- **Service Layer Separation**:\n  - Layer 1 (abilities) = I/O operations\n  - Layer 2 (proxies) = Type safety + error handling\n  - Layer 3 (agent services) = Orchestration + business logic\n- **Utility Modularity**: Shared types/errors in `src/abilities/types.ts`\n\n### Architecture Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Layer 3: Agent Orchestration\"\n        Agent[template-agent-typescript]\n        Memory[Memory Service]\n        Bot[Bot Integration]\n        Providers[LLM Providers]\n    end\n\n    subgraph \"Layer 2: Ability Proxies\"\n        FileProxy[FileOperationsProxy]\n        DeployProxy[DeploymentProxy]\n        TunnelProxy[TunnelingProxy]\n        DBProxy[DatabaseProxy]\n        AbilityMgr[AbilityManager]\n    end\n\n    subgraph \"KADI Broker\"\n        Broker[kadi-broker]\n    end\n\n    subgraph \"Layer 1: KADI Abilities\"\n        FM[file-management-ability]\n        LRFM[local-remote-file-manager]\n        KT[kadi-tunnel-ability]\n        CFM[cloud-file-manager-ability]\n        Deploy[deploy-ability]\n        ADB[arcadedb-ability]\n        CR[container-registry-ability]\n    end\n\n    Agent -->|load abilities| AbilityMgr\n    Memory --> DBProxy\n    Bot --> FileProxy\n    Bot --> TunnelProxy\n\n    AbilityMgr -->|tool invocation| Broker\n    FileProxy -->|tool invocation| Broker\n    DeployProxy -->|tool invocation| Broker\n    TunnelProxy -->|tool invocation| Broker\n    DBProxy -->|tool invocation| Broker\n\n    Broker <-->|JSON-RPC 2.0| FM\n    Broker <-->|JSON-RPC 2.0| LRFM\n    Broker <-->|JSON-RPC 2.0| KT\n    Broker <-->|JSON-RPC 2.0| CFM\n    Broker <-->|JSON-RPC 2.0| Deploy\n    Broker <-->|JSON-RPC 2.0| ADB\n    Broker <-->|JSON-RPC 2.0| CR\n\n    FM -.->|events| Agent\n    Deploy -.->|events| Agent\n    KT -.->|events| Agent\n```\n\n## Components and Interfaces\n\n### Component 1: AbilityManager\n\n**Purpose:** Orchestrates loading, health monitoring, and failover for all 7 abilities\n\n**Interfaces:**\n```typescript\nclass AbilityManager {\n  constructor(client: KadiClient)\n\n  // Load all abilities\n  async loadAll(): Promise<Result<void, AbilityError>>\n\n  // Load specific ability\n  async loadAbility(name: string): Promise<Result<AbilityProxy, AbilityError>>\n\n  // Get loaded ability proxy\n  getFileOperations(): FileOperationsProxy | null\n  getDeployment(): DeploymentProxy | null\n  getTunneling(): TunnelingProxy | null\n  getDatabase(): DatabaseProxy | null\n\n  // Health monitoring\n  async checkHealth(): Promise<Map<string, boolean>>\n\n  // Graceful shutdown\n  async dispose(): Promise<void>\n}\n```\n\n**Dependencies:**\n- KadiClient (for loading abilities)\n- Event subscriptions for ability health events\n\n**Reuses:**\n- Provider Manager pattern (`src/providers/provider-manager.ts`)\n- Health check logic\n- Retry/fallback patterns\n\n### Component 2: FileOperationsProxy\n\n**Purpose:** Unified interface for all file operations across 3 abilities\n\n**Interfaces:**\n```typescript\nclass FileOperationsProxy {\n  constructor(abilities: {\n    fileManagement: any,      // file-management-ability\n    localRemote: any,         // local-remote-file-manager-ability\n    cloudFileManager: any     // cloud-file-manager-ability\n  })\n\n  // SSH/SCP operations (via file-management-ability)\n  async uploadViaSSH(params: SSHUploadParams): Promise<Result<void, FileError>>\n  async downloadViaSSH(params: SSHDownloadParams): Promise<Result<void, FileError>>\n  async executeRemoteCommand(params: SSHCommandParams): Promise<Result<string, FileError>>\n\n  // Local file serving (via local-remote-file-manager-ability)\n  async startFileServer(params: FileServerParams): Promise<Result<FileServerInfo, FileError>>\n  async stopFileServer(serverId: string): Promise<Result<void, FileError>>\n\n  // Cloud operations (via cloud-file-manager-ability)\n  async uploadToCloud(params: CloudUploadParams): Promise<Result<CloudFile, FileError>>\n  async downloadFromCloud(params: CloudDownloadParams): Promise<Result<void, FileError>>\n  async listCloudFiles(params: CloudListParams): Promise<Result<CloudFile[], FileError>>\n}\n```\n\n**Dependencies:**\n- 3 ability proxies (file-management, local-remote, cloud-file-manager)\n- Result<T, E> for error handling\n\n**Reuses:**\n- Result type from `src/common/result.ts`\n- FileError type pattern from `src/common/types.ts`\n- Error classification from `src/providers/anthropic-provider.ts:302-334`\n\n### Component 3: DeploymentProxy\n\n**Purpose:** Wrapper for deploy-ability with typed methods\n\n**Interfaces:**\n```typescript\nclass DeploymentProxy {\n  constructor(deployAbility: any)\n\n  // Deploy Model Manager Gateway\n  async deployModelManager(params: DeploymentParams): Promise<Result<DeploymentInfo, DeployError>>\n\n  // Monitor deployment progress via events\n  subscribeToProgress(callback: (progress: DeployProgress) => void): () => void\n\n  // Check deployment status\n  async getStatus(deploymentId: string): Promise<Result<DeploymentStatus, DeployError>>\n}\n```\n\n**Dependencies:**\n- deploy-ability proxy\n- Event subscription for 'deploy.progress', 'deploy.completed', 'deploy.failed'\n\n**Reuses:**\n- Event subscription pattern from `src/index.ts:174-188`\n- Result type\n\n### Component 4: TunnelingProxy\n\n**Purpose:** Unified interface for tunneling (prefers kadi-tunnel over ngrok/serveo)\n\n**Interfaces:**\n```typescript\nclass TunnelingProxy {\n  constructor(abilities: {\n    kadiTunnel: any,          // kadi-tunnel-ability (preferred)\n    localRemote: any          // local-remote-file-manager-ability (fallback)\n  })\n\n  // Create tunnel (prefers kadi-tunnel)\n  async createTunnel(params: TunnelParams): Promise<Result<TunnelInfo, TunnelError>>\n\n  // List active tunnels\n  async listTunnels(): Promise<Result<TunnelInfo[], TunnelError>>\n\n  // Destroy tunnel\n  async destroyTunnel(tunnelId: string): Promise<Result<void, TunnelError>>\n}\n```\n\n**Dependencies:**\n- kadi-tunnel-ability (primary)\n- local-remote-file-manager-ability (fallback if kadi-tunnel unavailable)\n\n**Reuses:**\n- Fallback pattern from `src/providers/provider-manager.ts`\n\n### Component 5: DatabaseProxy\n\n**Purpose:** Wrapper for arcadedb-ability (Docker operations only, NOT queries)\n\n**Interfaces:**\n```typescript\nclass DatabaseProxy {\n  constructor(arcadedbAbility: any)\n\n  // Docker container management\n  async startContainer(params: ContainerParams): Promise<Result<ContainerInfo, DBError>>\n  async stopContainer(containerId: string): Promise<Result<void, DBError>>\n  async backupDatabase(params: BackupParams): Promise<Result<string, DBError>>\n}\n```\n\n**Dependencies:**\n- arcadedb-ability proxy\n- Does NOT replace existing ArcadeDBAdapter (that stays for Cypher queries)\n\n**Reuses:**\n- Result type\n- Maintains coexistence with `src/memory/arcadedb-adapter.ts`\n\n### Component 6: ContainerRegistryProxy (Optional)\n\n**Purpose:** Wrapper for container-registry-ability\n\n**Interfaces:**\n```typescript\nclass ContainerRegistryProxy {\n  constructor(containerRegistryAbility: any)\n\n  async pushImage(params: ImagePushParams): Promise<Result<void, RegistryError>>\n  async pullImage(params: ImagePullParams): Promise<Result<void, RegistryError>>\n  async listImages(): Promise<Result<ImageInfo[], RegistryError>>\n}\n```\n\n**Dependencies:**\n- container-registry-ability proxy\n\n**Reuses:**\n- Result type\n\n## Data Models\n\n### AbilityError (Shared Error Type)\n\n```typescript\nexport enum AbilityErrorType {\n  CONNECTION_FAILED = 'CONNECTION_FAILED',    // Ability not reachable\n  TOOL_NOT_FOUND = 'TOOL_NOT_FOUND',          // Tool doesn't exist\n  TIMEOUT = 'TIMEOUT',                        // Invocation timeout\n  INVALID_INPUT = 'INVALID_INPUT',            // Schema validation failed\n  ABILITY_ERROR = 'ABILITY_ERROR',            // Ability-specific error\n  NETWORK_ERROR = 'NETWORK_ERROR',            // Network issue\n  UNKNOWN = 'UNKNOWN'                         // Catch-all\n}\n\nexport interface AbilityError {\n  type: AbilityErrorType;\n  message: string;\n  abilityName: string;\n  toolName?: string;\n  originalError?: any;\n}\n```\n\n### FileServerInfo (Local File Serving)\n\n```typescript\nexport interface FileServerInfo {\n  serverId: string;          // Unique server identifier\n  localUrl: string;          // http://localhost:8080\n  tunnelUrl?: string;        // Public tunnel URL if enabled\n  directory: string;         // Served directory path\n  port: number;              // Server port\n}\n```\n\n### DeploymentInfo (Model Manager Deployment)\n\n```typescript\nexport interface DeploymentInfo {\n  deploymentId: string;      // Unique deployment ID\n  gatewayUrl: string;        // https://gateway.example.com\n  apiKey: string;            // Generated API key\n  status: 'PROVISIONING' | 'RUNNING' | 'FAILED';\n  dropletId?: string;        // Digital Ocean droplet ID\n  ipAddress?: string;        // Public IP address\n}\n\nexport interface DeployProgress {\n  deploymentId: string;\n  stage: 'provisioning' | 'waiting' | 'configuring' | 'registering';\n  message: string;\n  percentage?: number;       // 0-100\n}\n```\n\n### TunnelInfo (Secure Tunneling)\n\n```typescript\nexport interface TunnelInfo {\n  tunnelId: string;          // Unique tunnel identifier\n  subdomain: string;         // t.kadi.build subdomain\n  publicUrl: string;         // https://subdomain.t.kadi.build\n  localPort: number;         // Local service port\n  provider: 'kadi-tunnel' | 'ngrok' | 'serveo' | 'localtunnel';\n  sslEnabled: boolean;       // Let's Encrypt certificate\n}\n```\n\n### CloudFile (Cloud Storage)\n\n```typescript\nexport interface CloudFile {\n  id: string;                // Provider-specific ID\n  name: string;              // File name\n  path: string;              // Full path in cloud storage\n  size: number;              // Bytes\n  mimeType?: string;         // Content type\n  modifiedAt: Date;          // Last modification time\n  provider: 's3' | 'gcs' | 'azure' | 'dropbox' | 'drive' | 'box';\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Scenario: Ability Not Available**\n   - **Handling:** AbilityManager detects during loadAll(), marks as unavailable\n   - **User Impact:** Agent logs warning, continues with reduced functionality\n   - **Recovery:** Periodic retry (every 30s) with exponential backoff\n\n2. **Scenario: Tool Invocation Timeout**\n   - **Handling:** Protocol.invokeTool() respects timeout parameter (default 30s)\n   - **User Impact:** Error returned to caller with TIMEOUT error type\n   - **Recovery:** Retry up to 3 times for idempotent operations\n\n3. **Scenario: Network Failure During Long Operation**\n   - **Handling:** Ability emits progress events; agent detects missing events\n   - **User Impact:** Last known progress shown, \"Connection lost\" message\n   - **Recovery:** Automatic reconnection, query status via separate tool\n\n4. **Scenario: Invalid Tool Input**\n   - **Handling:** KADI broker validates against JSON schema before invocation\n   - **User Impact:** Immediate error with schema validation details\n   - **Recovery:** Log error, fix input, retry\n\n5. **Scenario: Ability Crashes Mid-Operation**\n   - **Handling:** Broker detects WebSocket disconnect, removes from registry\n   - **User Impact:** Tool invocation returns CONNECTION_FAILED error\n   - **Recovery:** AbilityManager attempts to reload ability, falls back to alternative if available\n\n6. **Scenario: Multiple Abilities Provide Same Tool**\n   - **Handling:** Network membership determines visibility; use routing hints\n   - **User Impact:** Transparent - correct ability invoked based on network\n   - **Recovery:** N/A - designed behavior\n\n### Error Propagation Pattern\n\n```typescript\n// Example: DeploymentProxy error handling\nasync deployModelManager(params: DeploymentParams): Promise<Result<DeploymentInfo, DeployError>> {\n  try {\n    const result = await this.deployAbility.deploy_model_manager(params);\n    return ok(result);\n  } catch (error: any) {\n    // Classify error\n    const errorType = this.classifyError(error);\n\n    // Create typed error\n    const deployError: DeployError = {\n      type: errorType,\n      message: error.message || 'Deployment failed',\n      abilityName: 'deploy-ability',\n      toolName: 'deploy_model_manager',\n      originalError: error\n    };\n\n    // Log for debugging\n    this.logger.error('Deployment failed', deployError);\n\n    // Return Result.err\n    return err(deployError);\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Scope:** Individual proxy classes with mocked abilities\n\n**Test Files:**\n- `test/abilities/file-operations-proxy.test.ts`\n- `test/abilities/deployment-proxy.test.ts`\n- `test/abilities/tunneling-proxy.test.ts`\n- `test/abilities/ability-manager.test.ts`\n\n**Key Tests:**\n- ✓ Proxy methods correctly invoke ability tools\n- ✓ Error classification works for various error types\n- ✓ Result<T, E> pattern used consistently\n- ✓ Timeout handling respects configuration\n- ✓ Event subscriptions work correctly\n\n**Mocking Strategy:**\n```typescript\n// Example: Mock ability proxy\nconst mockFileManagement = {\n  upload_via_ssh: vi.fn().mockResolvedValue({ success: true }),\n  download_via_ssh: vi.fn().mockResolvedValue({ success: true })\n};\n\n// Test\ndescribe('FileOperationsProxy', () => {\n  it('should upload file via SSH', async () => {\n    const proxy = new FileOperationsProxy({ fileManagement: mockFileManagement });\n    const result = await proxy.uploadViaSSH({ /* params */ });\n    expect(result.success).toBe(true);\n    expect(mockFileManagement.upload_via_ssh).toHaveBeenCalledWith(/* params */);\n  });\n});\n```\n\n### Integration Testing\n\n**Scope:** Agent + Broker + Single Ability (no external services)\n\n**Test Files:**\n- `test/integration/file-management-integration.test.ts`\n- `test/integration/deployment-integration.test.ts`\n- `test/integration/ability-manager-integration.test.ts`\n\n**Key Tests:**\n- ✓ Agent can load ability via broker\n- ✓ Tool invocation returns expected results\n- ✓ Event pub/sub works correctly\n- ✓ Network isolation works (tools only visible in correct networks)\n- ✓ Ability reconnection after disconnect\n\n**Setup Pattern:**\n```typescript\n// Example: Integration test setup\ndescribe('File Management Integration', () => {\n  let broker: BrokerProcess;\n  let ability: AbilityProcess;\n  let agent: KadiClient;\n\n  beforeEach(async () => {\n    broker = await startTestBroker({ port: 18080 });\n    ability = await startAbility('file-management', { broker: 'ws://localhost:18080' });\n    agent = new KadiClient({ broker: 'ws://localhost:18080', networks: ['global'] });\n    await agent.connect();\n  });\n\n  afterEach(async () => {\n    await agent.disconnect();\n    await ability.kill();\n    await broker.kill();\n  });\n\n  it('should upload file via SSH', async () => {\n    const fileOps = await agent.load('file-management', 'broker');\n    const result = await fileOps.upload_via_ssh({ /* params */ });\n    expect(result).toBeDefined();\n  });\n});\n```\n\n### End-to-End Testing\n\n**Scope:** Full system (agent + broker + all 7 abilities + external services)\n\n**Test Files (per Requirement 11):**\n- `test/e2e/kadi-tunnel.e2e.test.ts`\n- `test/e2e/local-remote-file-manager.e2e.test.ts`\n- `test/e2e/arcadedb.e2e.test.ts`\n- `test/e2e/cloud-file-manager.e2e.test.ts`\n- `test/e2e/container-registry.e2e.test.ts`\n- `test/e2e/deploy.e2e.test.ts`\n- `test/e2e/file-management.e2e.test.ts`\n- `test/e2e/all-abilities.e2e.test.ts` (integration test)\n\n**Key Tests:**\n- ✓ All 7 abilities connect to broker successfully\n- ✓ All ability tools are invocable from agent\n- ✓ Tool invocations return correct results\n- ✓ Progress events are published and received\n- ✓ Network isolation works correctly\n- ✓ Concurrent tool invocations work\n- ✓ Performance: Tool invocation overhead <100ms\n- ✓ Failure scenarios: Ability crashes, network failures, timeouts\n\n**E2E Test Structure:**\n```typescript\ndescribe('File Management E2E', () => {\n  let testEnv: E2ETestEnvironment;\n\n  beforeAll(async () => {\n    testEnv = await setupE2EEnvironment({\n      broker: { port: 18080 },\n      abilities: ['file-management'],\n      agent: { networks: ['global', 'file-ops'] }\n    });\n  });\n\n  afterAll(async () => {\n    await testEnv.teardown();\n  });\n\n  it('should complete full SSH upload workflow', async () => {\n    // 1. Agent loads ability\n    const fileOps = testEnv.abilityManager.getFileOperations();\n    expect(fileOps).not.toBeNull();\n\n    // 2. Upload file via SSH\n    const result = await fileOps!.uploadViaSSH({\n      host: 'test-server',\n      username: 'test-user',\n      localPath: '/tmp/test-file.txt',\n      remotePath: '/home/test-user/test-file.txt'\n    });\n\n    // 3. Verify success\n    expect(result.success).toBe(true);\n\n    // 4. Verify file exists on remote server\n    const verifyResult = await fileOps!.executeRemoteCommand({\n      host: 'test-server',\n      username: 'test-user',\n      command: 'ls -la /home/test-user/test-file.txt'\n    });\n    expect(verifyResult.success).toBe(true);\n    expect(verifyResult.data).toContain('test-file.txt');\n  });\n\n  it('should handle SSH connection failure gracefully', async () => {\n    const fileOps = testEnv.abilityManager.getFileOperations();\n\n    const result = await fileOps!.uploadViaSSH({\n      host: 'invalid-host',\n      username: 'test-user',\n      localPath: '/tmp/test-file.txt',\n      remotePath: '/home/test-user/test-file.txt'\n    });\n\n    expect(result.success).toBe(false);\n    expect(result.error.type).toBe(FileErrorType.CONNECTION_FAILED);\n  });\n});\n```\n\n### Performance Testing\n\n**Scope:** Measure broker overhead and concurrent operation performance\n\n**Key Metrics:**\n- Broker invocation overhead: <100ms (Requirement: Performance NFR)\n- Event delivery latency: <50ms (Requirement: Performance NFR)\n- Ability startup time: <5s (Requirement: Performance NFR)\n- Concurrent tool invocations: Support 10+ parallel calls\n\n**Performance Test Example:**\n```typescript\ndescribe('Performance Tests', () => {\n  it('should complete tool invocation with <100ms broker overhead', async () => {\n    const iterations = 100;\n    const overheads: number[] = [];\n\n    for (let i = 0; i < iterations; i++) {\n      const abilityStart = performance.now();\n      await ability.echo({ message: 'test' });\n      const abilityEnd = performance.now();\n      const abilityTime = abilityEnd - abilityStart;\n\n      const brokerStart = performance.now();\n      await protocol.invokeTool({ toolName: 'echo', toolInput: { message: 'test' } });\n      const brokerEnd = performance.now();\n      const brokerTime = brokerEnd - brokerStart;\n\n      overheads.push(brokerTime - abilityTime);\n    }\n\n    const avgOverhead = overheads.reduce((a, b) => a + b) / overheads.length;\n    expect(avgOverhead).toBeLessThan(100); // <100ms requirement\n  });\n});\n```\n\n## Implementation Phases\n\n### Phase 1: Ability Service Wrappers (Tasks 1-3)\n\n**Goal:** Create KadiClient wrappers for all 7 abilities\n\n**Deliverables:**\n- 7 ability services with proper KadiClient configuration\n- Tool registration for each ability\n- Event emission for long operations\n- Graceful shutdown handling\n\n### Phase 2: Agent-Side Proxy Layer (Tasks 4-8)\n\n**Goal:** Create typed proxy classes in agent codebase\n\n**Deliverables:**\n- AbilityManager for orchestration\n- FileOperationsProxy (3 abilities)\n- DeploymentProxy\n- TunnelingProxy\n- DatabaseProxy\n- ContainerRegistryProxy\n\n### Phase 3: Remove Old Implementations (Tasks 9-10)\n\n**Goal:** Delete file-management and deployment code\n\n**Deliverables:**\n- Remove src/file-management/\n- Remove src/deployment/\n- Update bot integrations to use new proxies\n- Update memory service to use DatabaseProxy for Docker ops\n\n### Phase 4: E2E Testing (Tasks 11-18)\n\n**Goal:** Comprehensive test coverage for all abilities\n\n**Deliverables:**\n- 7 E2E test suites (one per ability)\n- Integration test (all abilities + agent)\n- Performance tests\n- Failure scenario tests\n\n### Phase 5: Documentation & Deployment (Tasks 19-20)\n\n**Goal:** Production-ready deployment\n\n**Deliverables:**\n- README updates with ability integration docs\n- Deployment scripts for starting all abilities\n- Monitoring/health check setup\n- Migration guide from old implementation\n",
  "fileStats": {
    "size": 27088,
    "lines": 802,
    "lastModified": "2025-12-24T01:39:33.782Z"
  },
  "comments": []
}