{
  "id": "snapshot_1766037486148_jwsdw04vm",
  "approvalId": "approval_1766036705523_o6xduh3nt",
  "approvalTitle": "Design Document for Template Agent Rust",
  "version": 2,
  "timestamp": "2025-12-18T05:58:06.148Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Template Agent Rust\n\n## Overview\n\nThis document specifies the technical design for **template-agent-rust**, a production-ready Rust implementation of the KĀDI agent template. The design mirrors the architecture of template-agent-typescript while leveraging Rust's unique strengths: zero-cost abstractions, memory safety without garbage collection, fearless concurrency, and compile-time guarantees.\n\nThe agent will provide a high-performance foundation for building intelligent agents within the KĀDI ecosystem, supporting multi-LLM providers, hybrid memory systems, comprehensive file management, and autonomous deployment capabilities.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n*Note: If steering documents exist, they will be consulted. This design follows Rust best practices:*\n\n- **Cargo Workspace**: Organize crates for modularity and code reuse\n- **Async Runtime**: Use Tokio for async/await with proper task management\n- **Error Handling**: Custom error types per module using `thiserror` crate\n- **Type Safety**: Leverage Rust's type system to prevent invalid states\n- **Testing**: Unit tests with `#[cfg(test)]`, integration tests in `tests/` directory\n- **Documentation**: Comprehensive rustdoc comments for public APIs\n\n### Project Structure (structure.md)\n\n*Note: If steering documents exist, they will be consulted. This design proposes:*\n\n```\ntemplate-agent-rust/\n├── Cargo.toml                    # Workspace manifest\n├── crates/\n│   ├── template-agent/           # Main binary crate\n│   │   ├── src/\n│   │   │   ├── main.rs           # Entry point\n│   │   │   └── config.rs         # Configuration loading\n│   │   └── Cargo.toml\n│   ├── providers/                # LLM provider system\n│   │   ├── src/\n│   │   │   ├── lib.rs\n│   │   │   ├── types.rs\n│   │   │   ├── anthropic.rs\n│   │   │   ├── model_manager.rs\n│   │   │   └── manager.rs\n│   │   └── Cargo.toml\n│   ├── memory/                   # Hybrid memory system\n│   │   ├── src/\n│   │   │   ├── lib.rs\n│   │   │   ├── types.rs\n│   │   │   ├── file_storage.rs\n│   │   │   ├── database.rs\n│   │   │   └── service.rs\n│   │   └── Cargo.toml\n│   ├── file-management/          # File operations\n│   │   ├── src/\n│   │   │   ├── lib.rs\n│   │   │   └── proxy.rs\n│   │   └── Cargo.toml\n│   ├── deployment/               # Deployment service\n│   │   ├── src/\n│   │   │   ├── lib.rs\n│   │   │   └── service.rs\n│   │   └── Cargo.toml\n│   ├── bot/                      # Bot implementations\n│   │   ├── src/\n│   │   │   ├── lib.rs\n│   │   │   ├── slack.rs\n│   │   │   └── discord.rs\n│   │   └── Cargo.toml\n│   └── common/                   # Shared utilities\n│       ├── src/\n│       │   ├── lib.rs\n│       │   ├── result.rs\n│       │   └── error.rs\n│       └── Cargo.toml\n├── examples/                     # Usage examples\n│   ├── basic_chat.rs\n│   ├── slack_bot.rs\n│   └── memory_demo.rs\n├── tests/                        # Integration tests\n│   ├── provider_flow.rs\n│   └── memory_flow.rs\n└── docs/                         # Documentation\n    ├── architecture.md\n    └── deployment-guide.md\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**From template-agent-typescript:**\n- **Architecture Patterns**: Provider manager orchestration, hybrid memory layering, bot resilience patterns\n- **API Contracts**: KĀDI protocol message formats, event schemas, tool interfaces\n- **Configuration Model**: Environment variable structure, feature flags, deployment parameters\n\n### Integration Points\n\n**KĀDI Broker Integration:**\n- WebSocket connection using `tokio-tungstenite` crate\n- Tool registration and discovery via KĀDI protocol\n- Event subscription using async message handlers\n- Automatic reconnection with exponential backoff\n\n**External Services:**\n- **Anthropic API**: HTTP/2 client using `reqwest` with streaming support\n- **Model Manager Gateway**: OpenAI-compatible REST API client\n- **ArcadeDB**: HTTP-based graph database client for long-term memory\n- **Digital Ocean API**: Droplet management for autonomous deployment\n\n## Architecture\n\n### High-Level System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"User Interfaces\"\n        Slack[Slack Messages]\n        Discord[Discord Messages]\n    end\n\n    subgraph \"Bot Layer (Tokio Tasks)\"\n        SlackBot[SlackBot]\n        DiscordBot[DiscordBot]\n    end\n\n    subgraph \"Intelligence Layer\"\n        PM[ProviderManager]\n        AP[AnthropicProvider]\n        MMP[ModelManagerProvider]\n    end\n\n    subgraph \"Memory Layer (Arc + Mutex)\"\n        MS[MemoryService]\n        FS[FileStorageAdapter]\n        DBA[DatabaseAdapter]\n    end\n\n    subgraph \"File Operations\"\n        FM[FileManagerProxy]\n    end\n\n    subgraph \"Deployment\"\n        DS[DeployService]\n    end\n\n    subgraph \"KĀDI Infrastructure\"\n        Broker[KĀDI Broker]\n    end\n\n    Slack --> SlackBot\n    Discord --> DiscordBot\n    SlackBot --> PM\n    DiscordBot --> PM\n    SlackBot --> MS\n    DiscordBot --> MS\n    PM --> AP\n    PM --> MMP\n    MS --> FS\n    MS --> DBA\n    SlackBot --> Broker\n    DiscordBot --> Broker\n    FM --> Broker\n    DS --> Broker\n\n    style PM fill:#4A90E2\n    style MS fill:#9B59B6\n    style FM fill:#50C878\n    style DS fill:#FF6B6B\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each module (`.rs` file) handles one specific domain or concern\n- **Component Isolation**: Providers, memory, deployment are separate crates with defined boundaries\n- **Service Layer Separation**: Bot → Provider → Memory → Storage layers with clear interfaces\n- **Trait-Based Abstraction**: Use traits for polymorphism (e.g., `LLMProvider` trait, `StorageAdapter` trait)\n- **Ownership and Borrowing**: Leverage Rust's ownership for thread-safe concurrency without locks where possible\n- **Arc + Mutex Pattern**: Shared state wrapped in `Arc<Mutex<T>>` for safe concurrent access\n\n## Components and Interfaces\n\n### Component 1: Provider System\n\n**Purpose:** Abstract multiple LLM providers behind unified interface with routing, fallback, and health monitoring\n\n**Public Interface (Trait):**\n```rust\n#[async_trait]\npub trait LLMProvider: Send + Sync {\n    fn name(&self) -> &str;\n\n    async fn chat(\n        &self,\n        messages: &[Message],\n        options: Option<&ChatOptions>,\n    ) -> Result<String, ProviderError>;\n\n    async fn stream_chat(\n        &self,\n        messages: &[Message],\n        options: Option<&ChatOptions>,\n    ) -> Result<Pin<Box<dyn Stream<Item = Result<String, ProviderError>>>>, ProviderError>;\n\n    async fn get_available_models(&self) -> Result<Vec<String>, ProviderError>;\n\n    async fn is_healthy(&self) -> bool;\n\n    fn reset_health(&mut self);\n}\n```\n\n**ProviderManager API:**\n```rust\npub struct ProviderManager {\n    providers: HashMap<String, Arc<RwLock<Box<dyn LLMProvider>>>>,\n    health_status: Arc<RwLock<HashMap<String, ProviderHealth>>>,\n    config: ProviderConfig,\n}\n\nimpl ProviderManager {\n    pub fn new(providers: Vec<Box<dyn LLMProvider>>, config: ProviderConfig) -> Self;\n\n    pub async fn chat(\n        &self,\n        messages: &[Message],\n        options: Option<&ChatOptions>,\n    ) -> Result<String, ProviderError>;\n\n    pub async fn stream_chat(\n        &self,\n        messages: &[Message],\n        options: Option<&ChatOptions>,\n    ) -> Result<Pin<Box<dyn Stream<Item = Result<String, ProviderError>>>>, ProviderError>;\n\n    pub async fn get_health_status(&self) -> HashMap<String, ProviderHealth>;\n\n    fn select_provider(&self, model: Option<&str>) -> &str;\n}\n```\n\n**Dependencies:**\n- `reqwest` for HTTP clients\n- `tokio` for async runtime\n- `futures` for stream combinators\n- `serde` for JSON serialization\n\n**Reuses:** N/A (new implementation)\n\n---\n\n### Component 2: Memory Service\n\n**Purpose:** Hybrid memory system with JSON file storage (short-term) and database (long-term) with automatic archival\n\n**Public Interface:**\n```rust\npub struct MemoryService {\n    file_storage: Arc<FileStorageAdapter>,\n    db_adapter: Option<Arc<DatabaseAdapter>>,\n    is_db_available: AtomicBool,\n    archive_threshold: usize,\n    provider_manager: Arc<ProviderManager>,\n}\n\nimpl MemoryService {\n    pub async fn new(\n        memory_path: PathBuf,\n        db_url: Option<String>,\n        provider_manager: Arc<ProviderManager>,\n    ) -> Result<Self, MemoryError>;\n\n    pub async fn store_message(\n        &self,\n        user_id: &str,\n        channel_id: &str,\n        message: ConversationMessage,\n    ) -> Result<(), MemoryError>;\n\n    pub async fn retrieve_context(\n        &self,\n        user_id: &str,\n        channel_id: &str,\n        limit: Option<usize>,\n    ) -> Result<Vec<ConversationMessage>, MemoryError>;\n\n    pub async fn store_preference(\n        &self,\n        user_id: &str,\n        key: &str,\n        value: serde_json::Value,\n    ) -> Result<(), MemoryError>;\n\n    pub async fn get_preference(\n        &self,\n        user_id: &str,\n        key: &str,\n    ) -> Result<Option<serde_json::Value>, MemoryError>;\n\n    pub async fn search_long_term(\n        &self,\n        user_id: &str,\n        query: &str,\n    ) -> Result<Vec<MemoryEntry>, MemoryError>;\n}\n```\n\n**StorageAdapter Trait:**\n```rust\n#[async_trait]\npub trait StorageAdapter: Send + Sync {\n    async fn read_conversation(\n        &self,\n        user_id: &str,\n        channel_id: &str,\n    ) -> Result<Vec<ConversationMessage>, FileError>;\n\n    async fn write_conversation(\n        &self,\n        user_id: &str,\n        channel_id: &str,\n        messages: &[ConversationMessage],\n    ) -> Result<(), FileError>;\n}\n```\n\n**Dependencies:**\n- `tokio::fs` for async file I/O\n- `serde_json` for JSON serialization\n- `reqwest` for database HTTP client\n- `dashmap` for concurrent HashMap\n\n**Reuses:** Architecture pattern from TypeScript implementation\n\n---\n\n### Component 3: Bot System\n\n**Purpose:** Event-driven bot implementations for Slack and Discord with resilience patterns\n\n**Public Interface:**\n```rust\npub struct SlackBot {\n    client: Arc<KadiClient>,\n    provider_manager: Arc<ProviderManager>,\n    memory_service: Arc<MemoryService>,\n    bot_user_id: String,\n    circuit_breaker: Arc<RwLock<CircuitBreaker>>,\n}\n\nimpl SlackBot {\n    pub fn new(\n        client: Arc<KadiClient>,\n        provider_manager: Arc<ProviderManager>,\n        memory_service: Arc<MemoryService>,\n        bot_user_id: String,\n    ) -> Self;\n\n    pub async fn start(&self) -> Result<(), BotError>;\n\n    pub async fn stop(&self) -> Result<(), BotError>;\n\n    async fn handle_mention(&self, event: SlackMentionEvent) -> Result<(), BotError>;\n\n    async fn extract_model_preference(&self, text: &str) -> Option<String>;\n}\n```\n\n**CircuitBreaker Pattern:**\n```rust\npub struct CircuitBreaker {\n    failure_count: usize,\n    max_failures: usize,\n    state: CircuitState,\n    last_failure_time: Option<Instant>,\n    reset_timeout: Duration,\n}\n\npub enum CircuitState {\n    Closed,      // Normal operation\n    Open,        // Preventing requests\n    HalfOpen,    // Testing recovery\n}\n```\n\n**Dependencies:**\n- `kadi-core` (Rust KĀDI client library - to be created or FFI'd)\n- `tokio` for async event handling\n- `serde` for event deserialization\n\n**Reuses:** Resilience patterns from TypeScript BaseBot\n\n---\n\n### Component 4: File Management Proxy\n\n**Purpose:** Unified interface to file management abilities via KĀDI broker\n\n**Public Interface:**\n```rust\npub struct FileManagerProxy {\n    client: Arc<KadiClient>,\n}\n\nimpl FileManagerProxy {\n    pub fn new(client: Arc<KadiClient>) -> Self;\n\n    pub async fn start_file_server(\n        &self,\n        directory: PathBuf,\n        port: Option<u16>,\n    ) -> Result<FileServerInfo, FileError>;\n\n    pub async fn upload_to_cloud(\n        &self,\n        provider: &str,\n        local_path: PathBuf,\n        remote_path: &str,\n    ) -> Result<(), FileError>;\n\n    pub async fn share_container(\n        &self,\n        container_name: &str,\n    ) -> Result<ContainerRegistryInfo, FileError>;\n\n    pub async fn upload_via_ssh(\n        &self,\n        host: &str,\n        local_path: PathBuf,\n        remote_path: &str,\n    ) -> Result<(), FileError>;\n}\n```\n\n**Dependencies:**\n- `kadi-core` for tool invocation\n- `serde` for request/response serialization\n\n**Reuses:** KĀDI protocol contracts from TypeScript implementation\n\n---\n\n### Component 5: Deployment Service\n\n**Purpose:** Programmatic deployment of Model Manager Gateway to Digital Ocean\n\n**Public Interface:**\n```rust\npub struct DeployService {\n    config: DeployConfig,\n    http_client: reqwest::Client,\n}\n\nimpl DeployService {\n    pub fn new(config: DeployConfig) -> Self;\n\n    pub async fn deploy_model_manager(&self) -> Result<DeploymentResult, DeployError>;\n\n    pub async fn generate_api_key(\n        &self,\n        gateway_url: &str,\n        admin_key: &str,\n    ) -> Result<String, DeployError>;\n\n    pub async fn register_openai_models(\n        &self,\n        gateway_url: &str,\n        admin_key: &str,\n        openai_key: &str,\n    ) -> Result<Vec<String>, DeployError>;\n}\n```\n\n**Dependencies:**\n- `reqwest` for HTTP client\n- `serde_json` for API payloads\n\n**Reuses:** Deployment workflows from TypeScript implementation\n\n---\n\n### Component 6: Common Utilities\n\n**Purpose:** Shared types and utilities across all crates\n\n**Result Type:**\n```rust\npub type Result<T, E> = std::result::Result<T, E>;\n\n// Custom result wrapper with context\npub struct ResultExt<T, E> {\n    inner: Result<T, E>,\n}\n\nimpl<T, E> ResultExt<T, E> {\n    pub fn context(self, msg: &str) -> Self;\n}\n```\n\n**Error Types:**\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum ProviderError {\n    #[error(\"Authentication failed: {message}\")]\n    AuthFailed { message: String, provider: String },\n\n    #[error(\"Rate limit exceeded: {message}\")]\n    RateLimit { message: String, retry_after: Option<u64> },\n\n    #[error(\"Request timeout: {message}\")]\n    Timeout { message: String },\n\n    #[error(\"Provider unavailable: {provider}\")]\n    Unavailable { provider: String },\n\n    #[error(\"Model not found: {model}\")]\n    ModelNotFound { model: String, provider: String },\n\n    #[error(\"Invalid request: {message}\")]\n    InvalidRequest { message: String },\n\n    #[error(\"Unknown error: {message}\")]\n    Unknown { message: String },\n}\n```\n\n**Dependencies:**\n- `thiserror` for error derivation\n- `serde` for serialization\n\n**Reuses:** Error taxonomy from TypeScript implementation\n\n## Data Models\n\n### Message\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Message {\n    pub role: MessageRole,\n    pub content: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub name: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum MessageRole {\n    System,\n    User,\n    Assistant,\n}\n```\n\n### ChatOptions\n```rust\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ChatOptions {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub model: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_tokens: Option<u32>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub temperature: Option<f32>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option<Vec<Tool>>,\n}\n```\n\n### ConversationMessage\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConversationMessage {\n    pub role: MessageRole,\n    pub content: String,\n    pub timestamp: u64, // Unix timestamp in milliseconds\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub metadata: Option<HashMap<String, serde_json::Value>>,\n}\n```\n\n### ProviderConfig\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProviderConfig {\n    pub primary_provider: String,\n    pub fallback_provider: Option<String>,\n    pub retry_attempts: usize,\n    pub retry_delay_ms: u64,\n    pub health_check_interval_ms: u64,\n}\n```\n\n### ProviderHealth\n```rust\n#[derive(Debug, Clone)]\npub struct ProviderHealth {\n    pub is_healthy: bool,\n    pub consecutive_failures: usize,\n    pub last_check: SystemTime,\n}\n```\n\n### FileServerInfo\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileServerInfo {\n    pub server_id: String,\n    pub local_url: String,\n    pub tunnel_url: Option<String>,\n    pub port: u16,\n}\n```\n\n### DeploymentResult\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DeploymentResult {\n    pub gateway_url: String,\n    pub api_key: String,\n    pub deployment_id: String,\n    pub registered_models: Vec<String>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. Provider Authentication Failure\n- **Handling:** Return `ProviderError::AuthFailed` immediately, no retry\n- **User Impact:** Clear error message with instructions to check API key in `.env`\n- **Implementation:** Detect 401/403 HTTP status codes, map to error variant\n\n#### 2. Provider Rate Limit\n- **Handling:** Retry with exponential backoff (5s, 10s, 20s), return `ProviderError::RateLimit`\n- **User Impact:** Automatic retry with logging, eventual error if exhausted\n- **Implementation:** Detect 429 status code, parse `retry-after` header\n\n#### 3. Database Connection Failure\n- **Handling:** Graceful degradation to file-only mode, log warning\n- **User Impact:** System continues operating, no long-term search available\n- **Implementation:** Catch connection errors during initialization, set `is_db_available = false`\n\n#### 4. WebSocket Disconnection\n- **Handling:** Automatic reconnection with exponential backoff (1s, 2s, 4s, 8s, max 60s)\n- **User Impact:** Temporary message loss during reconnection, automatic recovery\n- **Implementation:** Tokio task that monitors connection state, triggers reconnect on drop\n\n#### 5. Circuit Breaker Open\n- **Handling:** Fast-fail requests without attempting provider call\n- **User Impact:** Error response indicating system is recovering\n- **Implementation:** Check circuit state before operation, return early if open\n\n#### 6. File I/O Permission Error\n- **Handling:** Return `MemoryError::FileError` with detailed path and permission info\n- **User Impact:** Clear error message with troubleshooting steps\n- **Implementation:** Catch `std::io::Error`, wrap with context\n\n#### 7. Invalid Configuration\n- **Handling:** Fail fast during initialization with detailed validation errors\n- **User Impact:** Agent won't start, clear error messages guide fixes\n- **Implementation:** Validate environment variables, return `ConfigError` with missing/invalid fields\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach:**\n- Use Rust's built-in `#[cfg(test)]` modules within each crate\n- Mock external dependencies using trait objects and test doubles\n- Test pure logic functions exhaustively\n\n**Key Components to Test:**\n- **ProviderManager**: Model-based routing logic, retry logic, circuit breaker state transitions\n- **MemoryService**: Archival threshold detection, summarization triggers, graceful degradation\n- **CircuitBreaker**: State transitions (closed → open → half-open), timeout logic\n- **Error Mapping**: HTTP status codes → custom error variants\n- **Configuration Validation**: Environment variable parsing, default values\n\n**Example:**\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_provider_selection_claude() {\n        let manager = ProviderManager::new(/* ... */);\n        assert_eq!(manager.select_provider(Some(\"claude-3-5-sonnet\")), \"anthropic\");\n    }\n\n    #[tokio::test]\n    async fn test_circuit_breaker_opens_after_max_failures() {\n        let mut cb = CircuitBreaker::new(3, Duration::from_secs(60));\n        for _ in 0..3 {\n            cb.record_failure();\n        }\n        assert_eq!(cb.state(), CircuitState::Open);\n    }\n}\n```\n\n### Integration Testing\n\n**Approach:**\n- Tests in `tests/` directory with full crate integration\n- Use test containers (testcontainers-rs) for ArcadeDB\n- Mock KĀDI broker and LLM APIs using `mockito` or `wiremock`\n\n**Key Flows to Test:**\n- **End-to-End Provider Flow**: Message → ProviderManager → AnthropicProvider → HTTP Mock → Response\n- **Memory Archival Flow**: 21 messages stored → automatic archival triggered → LLM summarization → database write\n- **Bot Resilience Flow**: Slack event → circuit breaker open → fast-fail response\n- **Deployment Flow**: DeployService → Digital Ocean API mock → deployment result\n\n**Example:**\n```rust\n#[tokio::test]\nasync fn test_memory_archival_triggers_at_threshold() {\n    let temp_dir = tempdir().unwrap();\n    let memory = MemoryService::new(temp_dir.path().to_path_buf(), None, provider_manager).await.unwrap();\n\n    // Store 21 messages\n    for i in 0..21 {\n        memory.store_message(\"user1\", \"channel1\", ConversationMessage {\n            role: MessageRole::User,\n            content: format!(\"Message {}\", i),\n            timestamp: i * 1000,\n            metadata: None,\n        }).await.unwrap();\n    }\n\n    // Verify only last 20 remain in file storage\n    let context = memory.retrieve_context(\"user1\", \"channel1\", None).await.unwrap();\n    assert_eq!(context.len(), 20);\n}\n```\n\n### End-to-End Testing\n\n**Approach:**\n- Manual testing with real services in development environment\n- Automated E2E tests with Docker Compose orchestration (optional)\n- Use real KĀDI broker, real Slack/Discord test workspaces\n\n**User Scenarios to Test:**\n1. **Slack Bot Flow**: @mention bot → bot retrieves memory → calls Claude → responds in thread\n2. **Provider Fallback**: Primary provider down → automatic fallback → successful response\n3. **Deployment Flow**: Run deployment script → verify droplet created → verify API key works\n4. **Memory Persistence**: Store conversations → restart agent → verify conversations loaded\n\n## Additional Design Considerations\n\n### Concurrency Model\n\n**Tokio Async Runtime:**\n- Single-threaded or multi-threaded runtime depending on `tokio::main` configuration\n- Use `tokio::spawn` for independent background tasks (health checks, archival)\n- Use `tokio::select!` for cancellation-safe event handling\n\n**Shared State:**\n- `Arc<RwLock<T>>` for read-heavy, write-rare data (provider health status)\n- `Arc<Mutex<T>>` for write-heavy data (conversation messages during archival)\n- `AtomicBool` for simple flags (database availability)\n\n**Message Passing:**\n- Use `tokio::sync::mpsc` channels for event queues between bot and handlers\n- Bounded channels to prevent memory growth under load\n\n### Performance Optimizations\n\n1. **Connection Pooling**: Reuse `reqwest::Client` instances (internally pools connections)\n2. **Lazy Initialization**: Defer database connection until first use\n3. **Streaming**: Use async streams for LLM responses to reduce latency\n4. **Batch Operations**: Batch conversation writes to reduce file I/O\n5. **Zero-Copy**: Use `Bytes` from `bytes` crate for network buffers\n\n### Security Considerations\n\n1. **Secret Management**: Load from environment variables only, never commit `.env`\n2. **TLS Verification**: Use `rustls` for TLS, verify certificates by default\n3. **Input Validation**: Validate all user inputs and API responses with Serde\n4. **Error Messages**: Sanitize errors before logging (remove API keys, paths)\n5. **Dependency Audits**: Run `cargo audit` in CI pipeline\n\n### Configuration Management\n\n**Environment Variables:**\n```rust\npub struct Config {\n    // Agent\n    pub agent_name: String,\n    pub agent_version: String,\n\n    // Providers\n    pub anthropic_api_key: String,\n    pub model_manager_base_url: Option<String>,\n    pub model_manager_api_key: Option<String>,\n    pub primary_provider: String,\n    pub fallback_provider: Option<String>,\n\n    // Memory\n    pub memory_data_path: PathBuf,\n    pub arcadedb_url: Option<String>,\n\n    // KĀDI\n    pub kadi_broker_url: String,\n    pub kadi_network: String,\n\n    // Bots\n    pub enable_slack_bot: bool,\n    pub slack_bot_user_id: Option<String>,\n    pub enable_discord_bot: bool,\n    pub discord_bot_user_id: Option<String>,\n\n    // Deployment\n    pub digital_ocean_token: Option<String>,\n}\n\nimpl Config {\n    pub fn from_env() -> Result<Self, ConfigError> {\n        dotenv::dotenv().ok();\n\n        Ok(Config {\n            agent_name: env::var(\"AGENT_NAME\")?,\n            anthropic_api_key: env::var(\"ANTHROPIC_API_KEY\")?,\n            // ... parse remaining variables with validation\n        })\n    }\n}\n```\n\n**Validation:**\n- Required variables: Fail fast if missing\n- Optional variables: Use `Option<T>` with `None` defaults\n- Type conversion: Parse integers, booleans with clear error messages\n- Path validation: Check directories exist and are writable\n\n### Build and Release\n\n**Cargo Features:**\n```toml\n[features]\ndefault = [\"slack-bot\", \"discord-bot\"]\nslack-bot = []\ndiscord-bot = []\ndeployment = [\"reqwest/json\"]\nfull = [\"slack-bot\", \"discord-bot\", \"deployment\"]\n```\n\n**Release Profile:**\n```toml\n[profile.release]\nopt-level = 3\nlto = true\ncodegen-units = 1\nstrip = true\n```\n\n**Cross-Compilation:**\n- Support Linux (x86_64-unknown-linux-gnu)\n- Support macOS (aarch64-apple-darwin, x86_64-apple-darwin)\n- Support Windows (x86_64-pc-windows-msvc)\n\n## Dependencies Summary\n\n### Core Dependencies\n- `tokio` (1.x): Async runtime with full features\n- `serde` (1.x): Serialization framework\n- `serde_json` (1.x): JSON support\n- `thiserror` (1.x): Error derivation\n- `anyhow` (1.x): Error handling in main\n- `tracing` (0.1): Structured logging\n- `tracing-subscriber` (0.3): Log formatting\n\n### Provider Dependencies\n- `reqwest` (0.11): HTTP client with rustls-tls\n- `futures` (0.3): Stream utilities\n- `async-trait` (0.1): Async trait support\n- `bytes` (1.x): Zero-copy buffers\n\n### Memory Dependencies\n- `dashmap` (5.x): Concurrent HashMap\n- `sled` (0.34): Embedded database (alternative to file storage)\n\n### Bot Dependencies\n- `kadi-core` (TBD): KĀDI client library\n\n### Development Dependencies\n- `tokio-test` (0.4): Async test utilities\n- `mockito` (1.x): HTTP mocking\n- `tempfile` (3.x): Temporary directories\n- `testcontainers` (0.15): Container orchestration\n\n## Migration Path from TypeScript\n\nFor teams familiar with template-agent-typescript:\n\n1. **Conceptual Mapping:**\n   - TypeScript `Promise<Result<T, E>>` → Rust `async fn -> Result<T, E>`\n   - TypeScript class → Rust struct with `impl` block\n   - TypeScript interface → Rust trait\n   - TypeScript `Map` → Rust `HashMap` or `DashMap`\n\n2. **Pattern Equivalence:**\n   - Circuit breaker pattern works identically\n   - Retry with exponential backoff translates directly\n   - Event subscription model remains the same\n   - Graceful degradation logic is equivalent\n\n3. **Performance Gains:**\n   - Expect 2-5x lower memory usage\n   - Expect 1.5-3x faster response times\n   - Expect significantly faster cold starts\n\n4. **Development Trade-offs:**\n   - Longer compile times (1-3 minutes vs 5-10 seconds)\n   - Steeper learning curve (ownership, lifetimes)\n   - More upfront design required (type system is strict)\n   - Better tooling for refactoring (compiler catches errors)\n",
  "fileStats": {
    "size": 27399,
    "lines": 921,
    "lastModified": "2025-12-18T05:44:49.633Z"
  },
  "comments": []
}