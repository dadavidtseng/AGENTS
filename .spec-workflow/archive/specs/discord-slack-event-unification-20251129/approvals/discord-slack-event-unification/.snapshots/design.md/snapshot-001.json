{
  "id": "snapshot_1764380684548_5bewxn2bc",
  "approvalId": "approval_1764380684540_frcy372jv",
  "approvalTitle": "Design Document - Discord/Slack Event-Based Unification",
  "version": 1,
  "timestamp": "2025-11-29T01:44:44.548Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Discord/Slack Event-Based Unification\n\n## Overview\n\nThis design implements a unified event-driven architecture for Discord and Slack bot integrations in template-agent-typescript. The design converts discord-bot.ts from polling to event subscription (matching slack-bot.ts), extracts shared publisher logic for MCP clients, and creates a common base class for bot implementations.\n\n**Key Design Goals:**\n1. **Event-Driven Discord**: Replace polling with KĀDI broker event subscriptions\n2. **Code Reuse**: Extract common patterns from slack-bot.ts and mcp-client-slack\n3. **Modularity**: Separate concerns across platform-specific and shared components\n4. **Maintainability**: Single source of truth for circuit breaker, retry, and metrics logic\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n*Note: No steering documents exist yet in .spec-workflow/steering/. Following general TypeScript best practices:*\n\n- **TypeScript Strict Mode**: All new code uses strict type checking with Zod schemas\n- **Error Handling**: Circuit breaker pattern with exponential backoff (existing pattern from slack-bot.ts)\n- **Logging**: Structured logging with consistent format `[COMPONENT] Action: Details {metadata}`\n- **Dependency Injection**: Constructor-based dependency injection for testability\n\n### Project Structure (structure.md)\n\n*Note: Following existing template-agent-typescript structure:*\n\n```\ntemplate-agent-typescript/\n├── src/\n│   ├── base-bot.ts           # NEW: Abstract base class\n│   ├── slack-bot.ts           # MODIFIED: Extends BaseBot\n│   ├── discord-bot.ts         # MODIFIED: Event-driven, extends BaseBot\n│   └── types/\n│       ├── slack-events.ts    # EXISTING: SlackMentionEventSchema\n│       └── discord-events.ts  # NEW: DiscordMentionEventSchema\n\nmcp-client-discord/\n├── src/\n│   ├── index.ts               # MODIFIED: Add KadiEventPublisher\n│   ├── kadi-publisher.ts      # NEW: Extracted from mcp-client-slack\n│   └── types.ts               # MODIFIED: Add DiscordMentionEvent\n\nmcp-client-slack/\n└── src/\n    ├── kadi-publisher.ts      # REFACTORED: Extract shared logic\n    └── types.ts               # EXISTING: SlackMentionEvent\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **KadiEventPublisher (mcp-client-slack)**: Complete publisher implementation with retry logic, graceful degradation, and connection management. Will be extracted and generalized for both platforms.\n\n- **Circuit Breaker Pattern (slack-bot.ts/discord-bot.ts)**: Both bots already implement identical circuit breaker logic (lines 102-117). Will be consolidated in BaseBot.\n\n- **Retry Logic with Exponential Backoff**: Both bots have identical retry mechanisms (lines 151-184). Will be moved to BaseBot.\n\n- **SlackMentionEventSchema**: Proven Zod schema pattern for event validation. Will be mirrored for Discord events.\n\n### Integration Points\n\n- **KĀDI Broker**: Both MCP clients will publish to separate topics (`slack.app_mention.{BOT_USER_ID}`, `discord.mention.{BOT_USER_ID}`)\n\n- **Claude API**: Shared integration through BaseBot (existing anthropic client initialization pattern)\n\n- **MCP Protocol**: Both bots use BrokerProtocol for tool invocation (existing pattern preserved)\n\n## Architecture\n\n### Event-Driven Pub/Sub Pattern\n\nThe architecture follows a clean separation between event publishers (MCP clients) and event subscribers (bot instances):\n\n```mermaid\ngraph TB\n    subgraph \"MCP Clients (Publishers)\"\n        MCP_S[mcp-client-slack<br/>SlackManager + KadiEventPublisher]\n        MCP_D[mcp-client-discord<br/>DiscordManager + KadiEventPublisher]\n    end\n\n    subgraph \"KĀDI Broker\"\n        BROKER[Event Bus<br/>Topics: slack.app_mention.{botId}<br/>discord.mention.{botId}]\n    end\n\n    subgraph \"template-agent-typescript (Subscribers)\"\n        BASE[BaseBot<br/>Circuit Breaker, Retry, Metrics, Claude API]\n        SLACK[SlackBot<br/>extends BaseBot]\n        DISCORD[DiscordBot<br/>extends BaseBot]\n    end\n\n    MCP_S -->|publishEvent| BROKER\n    MCP_D -->|publishEvent| BROKER\n    BROKER -->|subscribe| SLACK\n    BROKER -->|subscribe| DISCORD\n    SLACK -.->|inherits| BASE\n    DISCORD -.->|inherits| BASE\n```\n\n### Class Hierarchy Design\n\n```mermaid\nclassDiagram\n    class BaseBot {\n        <<abstract>>\n        #client: KadiClient\n        #anthropic: Anthropic\n        #protocol: BrokerProtocol\n        #failureCount: number\n        #isCircuitOpen: boolean\n        #totalRequests: number\n        +start(): void\n        +stop(): void\n        #recordFailure(error): void\n        #recordSuccess(): void\n        #logMetrics(): void\n        #invokeToolWithRetry(params, retryCount): Promise~any~\n        #processMessage(text, context): Promise~string~*\n        #handleEvent(event): Promise~void~*\n    }\n\n    class SlackBot {\n        -botUserId: string\n        -eventTopic: string\n        +start(): void\n        #handleEvent(event): Promise~void~\n        -subscribeToMentions(): void\n    }\n\n    class DiscordBot {\n        -botUserId: string\n        -eventTopic: string\n        +start(): void\n        #handleEvent(event): Promise~void~\n        -subscribeToMentions(): void\n    }\n\n    class KadiEventPublisher {\n        -client: KadiClient\n        -enabled: boolean\n        -brokerUrl: string\n        +connect(): Promise~void~\n        +publishEvent(topic, event): Promise~void~\n        +disconnect(): Promise~void~\n    }\n\n    BaseBot <|-- SlackBot : extends\n    BaseBot <|-- DiscordBot : extends\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**:\n  - `base-bot.ts`: Abstract bot logic only (circuit breaker, retry, Claude API)\n  - `slack-bot.ts`/`discord-bot.ts`: Platform-specific event handling and tool invocation\n  - `kadi-publisher.ts`: KĀDI connection and event publishing only\n\n- **Component Isolation**:\n  - Publishers (MCP clients) have zero knowledge of subscribers (bots)\n  - Bots subscribe to topics without knowing publisher implementation\n  - BaseBot has no platform-specific code (Discord/Slack agnostic)\n\n- **Service Layer Separation**:\n  - Event publishing: KadiEventPublisher\n  - Event subscription: BaseBot + platform bots\n  - Tool invocation: BrokerProtocol (existing MCP layer)\n  - AI processing: Anthropic client integration\n\n## Components and Interfaces\n\n### Component 1: BaseBot (Abstract Class)\n\n**Purpose:** Provides shared bot logic for circuit breaker, retry, metrics, and Claude API integration. Platform-agnostic foundation for all bot implementations.\n\n**Interfaces:**\n```typescript\nabstract class BaseBot {\n  // Lifecycle methods\n  abstract start(): void;\n  abstract stop(): void;\n\n  // Event processing (platform-specific implementation required)\n  protected abstract handleEvent(event: any): Promise<void>;\n  protected abstract processMessage(text: string, context: any): Promise<string>;\n\n  // Shared utilities (implemented in BaseBot)\n  protected recordFailure(error: any): void;\n  protected recordSuccess(): void;\n  protected logMetrics(): void;\n  protected invokeToolWithRetry(params: ToolInvocationParams, retryCount?: number): Promise<any>;\n  protected sleep(ms: number): Promise<void>;\n}\n```\n\n**Dependencies:**\n- `@kadi.build/core` (KadiClient)\n- `@anthropic-ai/sdk` (Anthropic)\n\n**Reuses:**\n- Existing circuit breaker pattern from slack-bot.ts:102-117\n- Existing retry logic from discord-bot.ts:151-184\n- Existing metrics tracking from both bots\n\n### Component 2: SlackBot (Concrete Implementation)\n\n**Purpose:** Handles Slack-specific event subscription and tool invocation using Slack MCP tools.\n\n**Interfaces:**\n```typescript\nclass SlackBot extends BaseBot {\n  constructor(client: KadiClient, anthropic: Anthropic, botUserId: string);\n\n  start(): void; // Subscribes to slack.app_mention.{botUserId}\n  stop(): void;  // Unsubscribes from events\n\n  protected handleEvent(event: SlackMentionEvent): Promise<void>;\n  protected processMessage(text: string, context: SlackContext): Promise<string>;\n\n  private subscribeToMentions(): void;\n}\n```\n\n**Dependencies:**\n- BaseBot (parent class)\n- SlackMentionEventSchema (types/slack-events.ts)\n- MCP Slack tools: `send_slack_message`\n\n**Reuses:**\n- BaseBot's circuit breaker and retry logic\n- Existing event subscription pattern from slack-bot.ts:189-197\n\n### Component 3: DiscordBot (Concrete Implementation)\n\n**Purpose:** Handles Discord-specific event subscription and tool invocation using Discord MCP tools.\n\n**Interfaces:**\n```typescript\nclass DiscordBot extends BaseBot {\n  constructor(client: KadiClient, anthropic: Anthropic, botUserId: string);\n\n  start(): void; // Subscribes to discord.mention.{botUserId}\n  stop(): void;  // Unsubscribes from events\n\n  protected handleEvent(event: DiscordMentionEvent): Promise<void>;\n  protected processMessage(text: string, context: DiscordContext): Promise<string>;\n\n  private subscribeToMentions(): void;\n}\n```\n\n**Dependencies:**\n- BaseBot (parent class)\n- DiscordMentionEventSchema (types/discord-events.ts)\n- MCP Discord tools: `send_discord_message`\n\n**Reuses:**\n- BaseBot's circuit breaker and retry logic\n- SlackBot's event subscription pattern (adapted for Discord topics)\n\n### Component 4: KadiEventPublisher (Shared Utility)\n\n**Purpose:** Manages KĀDI broker connection and event publishing for MCP clients. Provides graceful degradation when broker is unavailable.\n\n**Interfaces:**\n```typescript\nclass KadiEventPublisher {\n  constructor(config: { brokerUrl: string; clientName: string; networks: string[] });\n\n  async connect(): Promise<void>;\n  async publishEvent<T>(topic: string, event: T): Promise<void>;\n  async disconnect(): Promise<void>;\n}\n```\n\n**Dependencies:**\n- `@kadi.build/core` (KadiClient)\n\n**Reuses:**\n- Existing implementation from mcp-client-slack/src/kadi-publisher.ts (lines 32-262)\n- Will be parameterized to work for both Slack and Discord\n\n### Component 5: DiscordMentionEventSchema (New Type)\n\n**Purpose:** Zod schema for validating Discord mention events published to KĀDI broker.\n\n**Interfaces:**\n```typescript\nexport const DiscordMentionEventSchema = z.object({\n  id: z.string(),           // Unique mention ID\n  user: z.string(),         // Discord user ID\n  username: z.string(),     // Discord username\n  text: z.string(),         // Message text\n  channel: z.string(),      // Discord channel ID\n  channelName: z.string(),  // Discord channel name\n  guild: z.string(),        // Discord guild ID\n  ts: z.string(),           // Event timestamp\n  bot_id: z.string(),       // Discord bot ID for routing\n  timestamp: z.string().datetime(), // ISO 8601 publish time\n});\n\nexport type DiscordMentionEvent = z.infer<typeof DiscordMentionEventSchema>;\n```\n\n**Dependencies:**\n- `zod` for schema validation\n\n**Reuses:**\n- Pattern from SlackMentionEventSchema (types/slack-events.ts:22-46)\n- Adds Discord-specific fields (username, channelName, guild)\n\n## Data Models\n\n### SlackMentionEvent (Existing)\n```typescript\n{\n  id: string;           // Slack event timestamp (e.g., \"1234567890.123456\")\n  user: string;         // Slack user ID (e.g., \"U12345678\")\n  text: string;         // Message text with @mention removed\n  channel: string;      // Slack channel ID (e.g., \"C12345678\")\n  thread_ts: string;    // Thread timestamp for replies\n  ts: string;           // Event timestamp from Slack\n  bot_id: string;       // Slack bot user ID\n  timestamp: string;    // ISO 8601 datetime when published to KĀDI\n}\n```\n\n### DiscordMentionEvent (New)\n```typescript\n{\n  id: string;           // Discord message ID (snowflake)\n  user: string;         // Discord user ID (snowflake)\n  username: string;     // Discord username (e.g., \"john#1234\")\n  text: string;         // Message text with @mention removed\n  channel: string;      // Discord channel ID (snowflake)\n  channelName: string;  // Discord channel name (e.g., \"general\")\n  guild: string;        // Discord guild ID (snowflake)\n  ts: string;           // Message timestamp\n  bot_id: string;       // Discord bot user ID\n  timestamp: string;    // ISO 8601 datetime when published to KĀDI\n}\n```\n\n### Circuit Breaker State (Shared in BaseBot)\n```typescript\n{\n  failureCount: number;        // Current consecutive failures\n  lastFailureTime: number;     // Timestamp of last failure\n  isCircuitOpen: boolean;      // Circuit breaker state\n  maxFailures: number;         // Threshold before opening circuit (default: 3)\n  resetTimeMs: number;         // Time before attempting reset (default: 60000)\n  totalRequests: number;       // Total requests made\n  successCount: number;        // Successful requests\n  timeoutCount: number;        // Timeout failures\n}\n```\n\n## Event Flow Diagrams\n\n### Discord Event Flow (End-to-End)\n\n```mermaid\nsequenceDiagram\n    participant User as Discord User\n    participant Discord as Discord API\n    participant MCP as mcp-client-discord\n    participant Pub as KadiEventPublisher\n    participant Broker as KĀDI Broker\n    participant Bot as DiscordBot\n    participant Base as BaseBot\n    participant Claude as Claude API\n\n    User->>Discord: @mentions bot in channel\n    Discord->>MCP: Webhook/Gateway event\n    MCP->>MCP: Queue mention\n    MCP->>Pub: publishEvent(topic, event)\n    Pub->>Broker: WebSocket: discord.mention.{botId}\n    Broker->>Bot: Event subscription callback\n    Bot->>Base: handleEvent(event)\n    Base->>Base: Check circuit breaker\n    Base->>Bot: processMessage(text, context)\n    Bot->>Base: invokeToolWithRetry(\"send_discord_message\")\n    Base->>Base: Retry logic with backoff\n    Base->>Claude: Generate response\n    Claude-->>Base: AI response\n    Base->>Bot: Return message\n    Bot->>Discord: Send reply via MCP tool\n    Discord->>User: Bot replies\n```\n\n### Slack Event Flow (Existing, Now with BaseBot)\n\n```mermaid\nsequenceDiagram\n    participant User as Slack User\n    participant Slack as Slack API\n    participant MCP as mcp-client-slack\n    participant Pub as KadiEventPublisher\n    participant Broker as KĀDI Broker\n    participant Bot as SlackBot\n    participant Base as BaseBot\n    participant Claude as Claude API\n\n    User->>Slack: @mentions bot in channel\n    Slack->>MCP: Socket Mode event\n    MCP->>Pub: publishEvent(topic, event)\n    Pub->>Broker: WebSocket: slack.app_mention.{botId}\n    Broker->>Bot: Event subscription callback\n    Bot->>Base: handleEvent(event)\n    Base->>Base: Check circuit breaker\n    Base->>Bot: processMessage(text, context)\n    Bot->>Base: invokeToolWithRetry(\"send_slack_message\")\n    Base->>Base: Retry logic with backoff\n    Base->>Claude: Generate response\n    Claude-->>Base: AI response\n    Base->>Bot: Return message\n    Bot->>Slack: Send reply via MCP tool\n    Slack->>User: Bot replies\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Scenario: KĀDI Broker Connection Failure**\n   - **Context**: MCP client cannot connect to broker on startup\n   - **Handling**:\n     - KadiEventPublisher retries 5 times with exponential backoff (1s, 2s, 4s, 8s, 16s)\n     - After retries exhausted, publisher enters stub mode (graceful degradation)\n     - MCP client continues operating with queue-based fallback\n   - **User Impact**: Events not published to broker, but MCP tools (`get_discord_mentions`, `get_slack_mentions`) still work via queue\n\n2. **Scenario: Event Subscription Failure**\n   - **Context**: Bot cannot subscribe to KĀDI topic on startup\n   - **Handling**:\n     - Bot logs error and triggers circuit breaker\n     - Does NOT fall back to polling (requirement violation)\n     - Application fails fast with clear error message\n   - **User Impact**: Bot does not start until broker connectivity is restored\n\n3. **Scenario: Claude API Timeout**\n   - **Context**: Claude API takes >60 seconds to respond\n   - **Handling**:\n     - BaseBot's `invokeToolWithRetry` catches timeout\n     - Retries up to 3 times with exponential backoff\n     - Records failure and increments circuit breaker counter\n     - If 3 consecutive failures, opens circuit for 60 seconds\n   - **User Impact**: Bot stops responding temporarily, user sees no reply\n\n4. **Scenario: Event Publishing Failure**\n   - **Context**: KadiEventPublisher fails to publish event (network error, broker down)\n   - **Handling**:\n     - Publisher logs error and throws exception (fail-fast, no retry)\n     - MCP client catches exception and continues operating\n     - Event lost but system remains stable\n   - **User Impact**: Mention not delivered to bot in real-time, but available via queue fallback\n\n5. **Scenario: Invalid Event Schema**\n   - **Context**: Published event doesn't match DiscordMentionEventSchema or SlackMentionEventSchema\n   - **Handling**:\n     - Zod validation fails in bot's event handler\n     - Bot logs validation error with details\n     - Event discarded, circuit breaker NOT triggered (invalid data, not system failure)\n   - **User Impact**: Single mention lost, bot continues processing other events\n\n6. **Scenario: Circuit Breaker Open**\n   - **Context**: Circuit breaker opened after 3 consecutive Claude API failures\n   - **Handling**:\n     - BaseBot stops processing new events for 60 seconds\n     - Logs circuit breaker state every 10 requests\n     - After reset time, attempts one request to test recovery\n     - If successful, resets failure count and closes circuit\n   - **User Impact**: Bot unresponsive for 60 seconds, then resumes if issue resolved\n\n## Testing Strategy\n\n### Unit Testing\n\n**BaseBot Testing:**\n- Mock KadiClient and test circuit breaker logic independently\n- Test retry logic with simulated failures (timeout, network error, success on retry)\n- Test metrics tracking (totalRequests, successCount, timeoutCount)\n- Test abstract method contract enforcement\n\n**SlackBot/DiscordBot Testing:**\n- Mock BaseBot dependencies and test event subscription setup\n- Test event handler with valid and invalid event payloads\n- Test platform-specific tool invocation logic\n- Test start/stop lifecycle methods\n\n**KadiEventPublisher Testing:**\n- Mock WebSocket connection and test connect/disconnect\n- Test graceful degradation (stub mode) when broker unavailable\n- Test event publishing with retry logic\n- Test topic construction for different platforms\n\n### Integration Testing\n\n**End-to-End Event Flow:**\n- Start local KĀDI broker\n- Start mcp-client-discord with test Discord credentials\n- Start DiscordBot instance subscribed to test topic\n- Send test @mention through Discord\n- Verify event published to broker\n- Verify bot receives and processes event\n- Verify reply sent back to Discord channel\n\n**Multi-Bot Isolation:**\n- Start two SlackBot instances with different bot IDs\n- Publish events to both topics\n- Verify each bot only receives events for its own bot ID\n- Verify no cross-talk between bots\n\n**Circuit Breaker Integration:**\n- Simulate Claude API failures in test environment\n- Verify circuit opens after 3 failures\n- Verify bot stops processing during reset period\n- Verify circuit closes after successful request\n\n### End-to-End Testing\n\n**User Scenarios:**\n\n1. **Scenario: Discord User Mentions Bot**\n   - User sends `@bot hello` in Discord channel\n   - Bot receives event via KĀDI broker\n   - Bot processes message through Claude API\n   - Bot replies in same Discord channel\n   - Verify reply is contextually relevant\n\n2. **Scenario: Slack User Mentions Bot**\n   - User sends `@bot help` in Slack channel\n   - Bot receives event via KĀDI broker\n   - Bot processes message through Claude API\n   - Bot replies in Slack thread\n   - Verify reply maintains thread context\n\n3. **Scenario: Simultaneous Slack and Discord Mentions**\n   - Send @mention to SlackBot and DiscordBot simultaneously\n   - Both bots process events independently\n   - Both bots reply without interference\n   - Verify independent circuit breaker states\n\n4. **Scenario: Broker Restart During Operation**\n   - Bots running and processing events normally\n   - Stop KĀDI broker (simulate crash)\n   - Verify bots log connection errors\n   - Restart KĀDI broker\n   - Verify bots reconnect and resume processing\n\n## Migration Strategy\n\n### Phase 1: Extract Shared Publisher (Requirement 4)\n\n**Files Modified:**\n- `mcp-client-slack/src/kadi-publisher.ts` - Parameterize for reuse\n- `mcp-client-discord/src/kadi-publisher.ts` - Copy and adapt\n\n**Validation:**\n- mcp-client-slack still publishes Slack events correctly\n- Both publishers share identical connection/retry logic\n\n### Phase 2: Add Discord Event Publishing (Requirement 2)\n\n**Files Created:**\n- `template-agent-typescript/src/types/discord-events.ts`\n- `mcp-client-discord/src/kadi-publisher.ts`\n\n**Files Modified:**\n- `mcp-client-discord/src/index.ts` - Integrate KadiEventPublisher\n\n**Validation:**\n- Discord mentions published to `discord.mention.{botId}` topic\n- Existing `get_discord_mentions` tool still works (queue fallback)\n\n### Phase 3: Convert Discord Bot to Event-Driven (Requirement 1)\n\n**Files Modified:**\n- `template-agent-typescript/src/discord-bot.ts` - Remove polling, add subscription\n\n**Validation:**\n- DiscordBot receives events from KĀDI broker\n- DiscordBot no longer polls every 10 seconds\n- Event subscription failures trigger circuit breaker (no fallback to polling)\n\n### Phase 4: Extract BaseBot (Requirement 3)\n\n**Files Created:**\n- `template-agent-typescript/src/base-bot.ts`\n\n**Files Modified:**\n- `template-agent-typescript/src/slack-bot.ts` - Extend BaseBot\n- `template-agent-typescript/src/discord-bot.ts` - Extend BaseBot\n\n**Validation:**\n- Both bots share circuit breaker and retry logic\n- Both bots maintain independent state\n- Code duplication eliminated (DRY principle verified)\n\n### Phase 5: Platform-Specific Topics (Requirement 5)\n\n**Files Modified:**\n- All bots and publishers use `{platform}.{event_type}.{bot_id}` pattern\n\n**Validation:**\n- Multiple bots on same platform have unique topics\n- No event cross-talk between different bot instances\n- Topic pattern documented in README files\n\n## Performance Considerations\n\n- **Event Latency**: <100ms from publish to subscription callback (KĀDI broker WebSocket overhead)\n- **CPU Reduction**: Eliminating 10-second polling interval reduces idle CPU usage by ~90%\n- **Memory**: BaseBot abstractions add minimal overhead (~1KB per bot instance)\n- **Scalability**: Event-driven pattern allows unlimited subscribers per topic without N² polling conflicts\n\n## Security Considerations\n\n- **Bot ID Validation**: Ensure bot IDs in event topics are validated against expected format\n- **Event Schema Validation**: All events validated with Zod before processing (prevent injection attacks)\n- **Circuit Breaker**: Prevents DoS by limiting retry attempts when Claude API is slow\n- **Graceful Degradation**: Stub mode in publisher prevents cascading failures when broker unavailable\n",
  "fileStats": {
    "size": 22717,
    "lines": 623,
    "lastModified": "2025-11-29T01:37:06.227Z"
  },
  "comments": []
}