{
  "id": "snapshot_1764504164478_s14lxv5cr",
  "approvalId": "approval_1764504164473_yb099w6yp",
  "approvalTitle": "Design Document - Channel-Specific Interaction Patterns",
  "version": 1,
  "timestamp": "2025-11-30T12:02:44.478Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Simple Multi-Agent Orchestration\r\n\r\n**Spec Name:** `simple-multi-agents-orchestration`\r\n**Created:** 2025-11-30\r\n**Status:** Draft - Pending Approval\r\n\r\n---\r\n\r\n## Overview\r\n\r\nThis design document specifies the technical architecture for an intelligent multi-agent orchestration system where **agent-producer** coordinates three specialized worker agents (agent-artist, agent-designer, agent-programmer) with shadow agents for version control and rollback capability.\r\n\r\n**Key Design Principles:**\r\n- Event-driven architecture via KĀDI broker for decoupled agent communication\r\n- Multi-channel user input support with channel-specific interaction patterns\r\n- Git worktree isolation for concurrent task execution\r\n- Shadow agent pattern for continuous versioning and rollback capability\r\n- BaseBot inheritance for resilience patterns (circuit breaker, retry logic)\r\n\r\n---\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\n\r\n*Note: Steering documents not yet created. This section will be populated once steering documents are established.*\r\n\r\n**Expected Alignment:**\r\n- TypeScript for all agent implementations\r\n- KĀDI broker for event-driven communication\r\n- MCP (Model Context Protocol) for tool integration\r\n- Zod for schema validation\r\n\r\n### Project Structure (structure.md)\r\n\r\n*Note: Steering documents not yet created. This section will be populated once steering documents are established.*\r\n\r\n**Expected Structure:**\r\n```\r\nAGENTS/\r\n├── agent-producer/          # Orchestrator agent\r\n├── agent-artist/            # Worker agent (art/design)\r\n├── agent-designer/          # Worker agent (documentation)\r\n├── agent-programmer/        # Worker agent (code)\r\n├── shadow-agent-artist/     # Shadow monitor for artist\r\n├── shadow-agent-designer/   # Shadow monitor for designer\r\n├── shadow-agent-programmer/ # Shadow monitor for programmer\r\n└── shared/                  # Shared utilities (BaseBot)\r\n```\r\n\r\n---\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n1. **BaseBot (shared/base-bot.ts)**\r\n   - **Purpose**: Abstract base class providing resilience patterns\r\n   - **Reuse**: Worker agents and shadow agents will extend BaseBot\r\n   - **Features**:\r\n     - Circuit breaker (opens after 5 failures, resets after 60s)\r\n     - Exponential backoff retry (1s, 2s, 4s up to 3 attempts)\r\n     - Metrics tracking (total requests, success/timeout counts)\r\n     - Tool invocation with fault tolerance (`invokeToolWithRetry`)\r\n\r\n2. **KadiClient (@kadi.build/core)**\r\n   - **Purpose**: KĀDI broker communication client\r\n   - **Reuse**: All agents use KadiClient for event pub/sub and tool invocation\r\n   - **Features**:\r\n     - Event subscription (`subscribeToEvent`)\r\n     - Event publishing (`publishEvent`)\r\n     - Tool invocation via broker (`protocol.invokeTool`)\r\n     - Network isolation support\r\n\r\n3. **SlackBot and DiscordBot (agent-producer/src/bot/)**\r\n   - **Purpose**: Existing bot integrations extending BaseBot\r\n   - **Reuse**: agent-producer already has these; no duplication needed\r\n   - **Features**:\r\n     - Event subscription for mentions\r\n     - Anthropic Claude integration\r\n     - Message formatting and response handling\r\n\r\n### Integration Points\r\n\r\n1. **mcp-shrimp-task-manager (C:\\GitHub\\mcp-shrimp-task-manager)**\r\n   - **Integration**: agent-producer calls via broker protocol\r\n   - **Tools Used**:\r\n     - `shrimp__plan_task` - Create project specifications\r\n     - `shrimp__analyze_task` - Analyze complexity and scope\r\n     - `shrimp__split_tasks` - Break into atomic tasks\r\n     - `shrimp__list_tasks` - Query task status\r\n     - `shrimp__log_implementation` - Record task completion\r\n   - **Access Pattern**: `protocol.invokeTool({ targetAgent: 'mcp-shrimp-task-manager', toolName: 'shrimp__plan_task', ... })`\r\n\r\n2. **mcp-server-git**\r\n   - **Integration**: All agents use for git worktree management\r\n   - **Tools Used**:\r\n     - `git__worktree` (mode: 'add', 'remove', 'list')\r\n     - `git__push` (for agent-producer GitHub push)\r\n     - `git__commit` (for shadow agents)\r\n   - **Access Pattern**: `protocol.invokeTool({ targetAgent: 'mcp-server-git', toolName: 'git__worktree', ... })`\r\n\r\n3. **mcp-client-slack and mcp-client-discord**\r\n   - **Integration**: Publish events that agent-producer subscribes to\r\n   - **Event Topics**:\r\n     - `slack.app_mention.{botUserId}` - Slack mentions\r\n     - `discord.mention.{botUserId}` - Discord mentions\r\n   - **Data Flow**: MCP client → KĀDI broker (event) → agent-producer (subscriber)\r\n\r\n4. **KĀDI Broker**\r\n   - **Integration**: Central message bus for all agent communication\r\n   - **Configuration**: `kadi-broker/config/mcp-upstreams.json`\r\n   - **Networks**: global, artist, design, programmer, git, slack, discord\r\n\r\n---\r\n\r\n## Architecture\r\n\r\n### High-Level System Architecture\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"User Channels\"\r\n        U1[Slack User]\r\n        U2[Discord User]\r\n        U3[Claude Code User]\r\n        U4[Claude Desktop User]\r\n    end\r\n\r\n    subgraph \"Input Layer\"\r\n        MCP_SLACK[mcp-client-slack]\r\n        MCP_DISCORD[mcp-client-discord]\r\n        PRODUCER_TOOLS[agent-producer<br/>MCP Tools]\r\n    end\r\n\r\n    subgraph \"KĀDI Broker\"\r\n        BROKER[kadi-broker<br/>Event Bus + Tool Router]\r\n    end\r\n\r\n    subgraph \"Orchestrator\"\r\n        PRODUCER[agent-producer<br/>Orchestration Logic]\r\n    end\r\n\r\n    subgraph \"Task Management\"\r\n        SHRIMP[mcp-shrimp-task-manager<br/>Task Planning & Tracking]\r\n    end\r\n\r\n    subgraph \"Worker Agents\"\r\n        ARTIST[agent-artist<br/>extends BaseBot]\r\n        DESIGNER[agent-designer<br/>extends BaseBot]\r\n        PROGRAMMER[agent-programmer<br/>extends BaseBot]\r\n    end\r\n\r\n    subgraph \"Shadow Agents\"\r\n        S_ARTIST[shadow-agent-artist<br/>extends BaseBot]\r\n        S_DESIGNER[shadow-agent-designer<br/>extends BaseBot]\r\n        S_PROGRAMMER[shadow-agent-programmer<br/>extends BaseBot]\r\n    end\r\n\r\n    subgraph \"Version Control\"\r\n        GIT_MAIN[Main Repo<br/>agent-playground]\r\n        GIT_SHADOW_A[Shadow Repo<br/>artist]\r\n        GIT_SHADOW_D[Shadow Repo<br/>designer]\r\n        GIT_SHADOW_P[Shadow Repo<br/>programmer]\r\n    end\r\n\r\n    %% User to Input Layer\r\n    U1 -->|@mention| MCP_SLACK\r\n    U2 -->|@mention| MCP_DISCORD\r\n    U3 -->|tool call| PRODUCER_TOOLS\r\n    U4 -->|tool call| PRODUCER_TOOLS\r\n\r\n    %% Input Layer to Broker\r\n    MCP_SLACK -->|publish event| BROKER\r\n    MCP_DISCORD -->|publish event| BROKER\r\n    PRODUCER_TOOLS -->|register tools| BROKER\r\n\r\n    %% Broker to Orchestrator\r\n    BROKER <-->|events + tools| PRODUCER\r\n\r\n    %% Orchestrator to Task Manager\r\n    PRODUCER -->|tool invocation| SHRIMP\r\n\r\n    %% Orchestrator to Workers\r\n    PRODUCER -->|task events| ARTIST\r\n    PRODUCER -->|task events| DESIGNER\r\n    PRODUCER -->|task events| PROGRAMMER\r\n\r\n    %% Workers to Shadows\r\n    ARTIST -->|file events| S_ARTIST\r\n    DESIGNER -->|file events| S_DESIGNER\r\n    PROGRAMMER -->|file events| S_PROGRAMMER\r\n\r\n    %% Version Control\r\n    PRODUCER -->|git push| GIT_MAIN\r\n    S_ARTIST -->|git push| GIT_SHADOW_A\r\n    S_DESIGNER -->|git push| GIT_SHADOW_D\r\n    S_PROGRAMMER -->|git push| GIT_SHADOW_P\r\n\r\n    style BROKER fill:#e3f2fd\r\n    style PRODUCER fill:#fff9c4\r\n    style SHRIMP fill:#f3e5f5\r\n    style ARTIST fill:#c8e6c9\r\n    style DESIGNER fill:#c8e6c9\r\n    style PROGRAMMER fill:#c8e6c9\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n1. **Single File Responsibility**\r\n   - Each agent has clear orchestration/execution/monitoring role\r\n   - Separation of concerns: producer (orchestration), workers (execution), shadows (versioning)\r\n\r\n2. **Component Isolation**\r\n   - Workers operate in isolated git worktrees (no file conflicts)\r\n   - Shadow agents operate independently (passive monitoring)\r\n   - Network isolation via KĀDI broker networks\r\n\r\n3. **Service Layer Separation**\r\n   - **Presentation Layer**: SlackBot/DiscordBot/MCP Tools (user interaction)\r\n   - **Orchestration Layer**: agent-producer (workflow coordination)\r\n   - **Execution Layer**: Worker agents (task implementation)\r\n   - **Persistence Layer**: Shadow agents (version control)\r\n\r\n4. **Utility Modularity**\r\n   - BaseBot provides reusable resilience utilities\r\n   - KadiClient provides reusable communication utilities\r\n   - Shared types and interfaces in shared/ directory\r\n\r\n---\r\n\r\n## Channel-Specific Interaction Patterns\r\n\r\n### Pattern 1: Event-Driven Channels (Slack/Discord)\r\n\r\n**Architecture:**\r\n```\r\nUser @mention → mcp-client-slack/discord → KĀDI broker (publish event)\r\n→ agent-producer (subscribe event) → Process request → Respond to channel\r\n```\r\n\r\n**Interaction Flow:**\r\n\r\n1. **User Input**\r\n   - User sends `@bot Can you create a spinning cube app?` in Slack/Discord\r\n   - Platform-specific bot API captures mention\r\n\r\n2. **Event Publishing (by MCP clients)**\r\n   - `mcp-client-slack` publishes event:\r\n     ```json\r\n     {\r\n       \"topic\": \"slack.app_mention.U12345\",\r\n       \"data\": {\r\n         \"channel\": \"C98765\",\r\n         \"user\": \"U54321\",\r\n         \"text\": \"Can you create a spinning cube app?\",\r\n         \"ts\": \"1234567890.123456\"\r\n       }\r\n     }\r\n     ```\r\n\r\n3. **Event Subscription (by agent-producer)**\r\n   - agent-producer subscribes to `slack.app_mention.{botUserId}`\r\n   - Receives event through KĀDI broker\r\n   - Extracts user request from event data\r\n\r\n4. **Acknowledgment**\r\n   - agent-producer calls mcp-client-slack tool to send acknowledgment:\r\n     ```typescript\r\n     await protocol.invokeTool({\r\n       targetAgent: 'mcp-client-slack',\r\n       toolName: 'slack__post_message',\r\n       toolInput: {\r\n         channel: event.data.channel,\r\n         text: 'Got it! Planning your spinning cube project. This should take 1-2 minutes...'\r\n       }\r\n     });\r\n     ```\r\n\r\n5. **Progress Updates**\r\n   - Periodic status updates sent to same channel via mcp-client-slack/discord tools\r\n   - User sees real-time progress in their conversation thread\r\n\r\n6. **Completion Notification**\r\n   - Final message with results and approval request:\r\n     ```\r\n     All 5 tasks completed! Please review the changes:\r\n     - Task 1: Design doc created (24 lines added)\r\n     - Task 2: 3D model (cube.obj, 156KB)\r\n     ...\r\n     Reply 'approve' to merge to main branch.\r\n     ```\r\n\r\n**Key Characteristics:**\r\n- **Asynchronous**: Fire-and-forget event pattern\r\n- **Conversational**: Multi-turn dialogue in chat interface\r\n- **Contextual**: Thread-based conversation history\r\n- **Notification-based**: Proactive status updates\r\n\r\n---\r\n\r\n### Pattern 2: Tool-Based Channels (Claude Code/Desktop)\r\n\r\n**Architecture:**\r\n```\r\nUser tool call → Claude client → KĀDI broker (tool invocation)\r\n→ agent-producer MCP server → Process request → Return result\r\n```\r\n\r\n**Interaction Flow:**\r\n\r\n1. **User Input**\r\n   - User calls tool from Claude Code/Desktop:\r\n     ```\r\n     User: \"Can you create a spinning cube app?\"\r\n     Claude: [Calls plan_task tool]\r\n     ```\r\n\r\n2. **Tool Registration (by agent-producer)**\r\n   - agent-producer registers as MCP upstream with broker:\r\n     ```json\r\n     {\r\n       \"id\": \"agent-producer\",\r\n       \"type\": \"stdio\",\r\n       \"prefix\": \"producer\",\r\n       \"tools\": [\r\n         { \"name\": \"plan_task\", \"description\": \"...\" },\r\n         { \"name\": \"list_active_tasks\", \"description\": \"...\" },\r\n         { \"name\": \"get_task_status\", \"description\": \"...\" },\r\n         { \"name\": \"approve_completion\", \"description\": \"...\" }\r\n       ]\r\n     }\r\n     ```\r\n\r\n3. **Tool Invocation**\r\n   - Claude client sends tool invocation to broker:\r\n     ```json\r\n     {\r\n       \"tool\": \"producer__plan_task\",\r\n       \"input\": {\r\n         \"description\": \"Create a spinning cube app with color animation\"\r\n       }\r\n     }\r\n     ```\r\n\r\n4. **Synchronous Processing**\r\n   - agent-producer receives tool call\r\n   - Processes request (calls mcp-shrimp-task-manager, etc.)\r\n   - Returns structured result:\r\n     ```json\r\n     {\r\n       \"specName\": \"spinning-cube-app\",\r\n       \"taskCount\": 5,\r\n       \"tasks\": [\r\n         { \"id\": \"task-001\", \"description\": \"Design document\", \"assignedTo\": \"agent-designer\" },\r\n         ...\r\n       ],\r\n       \"estimatedDuration\": \"2-3 hours\",\r\n       \"status\": \"tasks_created\"\r\n     }\r\n     ```\r\n\r\n5. **User Review**\r\n   - Claude displays structured result to user\r\n   - User can call additional tools:\r\n     - `list_active_tasks()` - See current progress\r\n     - `get_task_status(taskId)` - Check specific task\r\n     - `approve_completion()` - Approve completed work\r\n\r\n6. **Completion Workflow**\r\n   - User calls `approve_completion()` tool\r\n   - agent-producer performs git push and cleanup\r\n   - Returns confirmation:\r\n     ```json\r\n     {\r\n       \"status\": \"approved_and_merged\",\r\n       \"branch\": \"main\",\r\n       \"commitHash\": \"abc123def\",\r\n       \"message\": \"All changes merged to main branch\"\r\n     }\r\n     ```\r\n\r\n**Key Characteristics:**\r\n- **Synchronous**: Request-response pattern with immediate results\r\n- **Structured**: JSON-based tool inputs/outputs\r\n- **Transactional**: Each tool call is independent\r\n- **Stateless**: Tool calls don't maintain conversation state\r\n\r\n---\r\n\r\n### Comparison Matrix\r\n\r\n| Aspect | Slack/Discord (Event-Driven) | Claude Code/Desktop (Tool-Based) |\r\n|--------|------------------------------|----------------------------------|\r\n| **Communication** | Asynchronous events | Synchronous tool calls |\r\n| **User Experience** | Conversational chat | Structured tool interface |\r\n| **Progress Updates** | Proactive push notifications | User polls via tools |\r\n| **State Management** | Conversation thread context | Stateless transactions |\r\n| **Response Format** | Natural language messages | Structured JSON |\r\n| **Approval Method** | Reply \"approve\" in chat | Call `approve_completion()` tool |\r\n| **Multi-turn Interaction** | Native (thread-based) | Explicit (multiple tool calls) |\r\n| **Error Handling** | Informative chat messages | JSON error objects |\r\n\r\n---\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: agent-producer (Orchestrator)\r\n\r\n**Purpose:** Central orchestrator coordinating all agents and managing workflow\r\n\r\n**Implementation:**\r\n- **File**: `agent-producer/src/index.ts` (existing structure)\r\n- **Dependencies**: KadiClient, existing SlackBot/DiscordBot\r\n- **Does NOT extend**: BaseBot (already has bot integrations)\r\n\r\n**Interfaces (MCP Tools for Claude Code/Desktop):**\r\n\r\n```typescript\r\ninterface ProducerTools {\r\n  /**\r\n   * Initiate task planning from user request\r\n   * Similar to mcp-shrimp-task-manager's plan_task\r\n   */\r\n  plan_task(input: {\r\n    description: string;\r\n  }): Promise<{\r\n    specName: string;\r\n    taskCount: number;\r\n    tasks: Array<{ id: string; description: string; assignedTo: string }>;\r\n    estimatedDuration: string;\r\n    status: string;\r\n  }>;\r\n\r\n  /**\r\n   * Show currently active tasks across all worker agents\r\n   */\r\n  list_active_tasks(): Promise<{\r\n    tasks: Array<{\r\n      taskId: string;\r\n      description: string;\r\n      assignedTo: string;\r\n      status: 'pending' | 'in_progress' | 'completed';\r\n      progress: number;\r\n    }>;\r\n  }>;\r\n\r\n  /**\r\n   * Get detailed status of specific task\r\n   */\r\n  get_task_status(input: {\r\n    taskId: string;\r\n  }): Promise<{\r\n    taskId: string;\r\n    description: string;\r\n    assignedTo: string;\r\n    status: string;\r\n    startedAt?: string;\r\n    completedAt?: string;\r\n    filesModified?: string[];\r\n    filesCreated?: string[];\r\n  }>;\r\n\r\n  /**\r\n   * User approval for merging completed work\r\n   */\r\n  approve_completion(): Promise<{\r\n    status: 'approved_and_merged' | 'no_pending_work' | 'already_approved';\r\n    branch?: string;\r\n    commitHash?: string;\r\n    message: string;\r\n  }>;\r\n}\r\n```\r\n\r\n**Event Subscriptions:**\r\n- `slack.app_mention.{botUserId}` - Slack user mentions\r\n- `discord.mention.{botUserId}` - Discord user mentions\r\n- `agents.agent-artist.tasks.completed` - Artist completion\r\n- `agents.agent-designer.tasks.completed` - Designer completion\r\n- `agents.agent-programmer.tasks.completed` - Programmer completion\r\n- `agents.agent-artist.tasks.failed` - Artist failures\r\n- `agents.agent-designer.tasks.failed` - Designer failures\r\n- `agents.agent-programmer.tasks.failed` - Programmer failures\r\n\r\n**Event Publications:**\r\n- `agents.agent-artist.tasks.assign` - Task assignments for artist\r\n- `agents.agent-designer.tasks.assign` - Task assignments for designer\r\n- `agents.agent-programmer.tasks.assign` - Task assignments for programmer\r\n- `agents.agent-artist.tasks.cleanup` - Cleanup requests for artist\r\n- `agents.agent-designer.tasks.cleanup` - Cleanup requests for designer\r\n- `agents.agent-programmer.tasks.cleanup` - Cleanup requests for programmer\r\n\r\n**Dependencies:**\r\n- mcp-shrimp-task-manager (via broker)\r\n- mcp-server-git (via broker)\r\n- mcp-client-slack (via broker)\r\n- mcp-client-discord (via broker)\r\n\r\n**Reuses:**\r\n- KadiClient for broker communication\r\n- Existing SlackBot and DiscordBot (already extend BaseBot)\r\n\r\n---\r\n\r\n### Component 2: Worker Agents (agent-artist, agent-designer, agent-programmer)\r\n\r\n**Purpose:** Execute assigned tasks in isolated git worktrees\r\n\r\n**Implementation:**\r\n- **Files**:\r\n  - `agent-artist/src/index.ts`\r\n  - `agent-designer/src/index.ts`\r\n  - `agent-programmer/src/index.ts`\r\n- **Extends**: BaseBot (for resilience patterns)\r\n- **Networks**:\r\n  - agent-artist: `['global', 'artist']`\r\n  - agent-designer: `['global', 'design']`\r\n  - agent-programmer: `['global', 'programmer']`\r\n\r\n**Interfaces (Internal):**\r\n\r\n```typescript\r\ninterface WorkerAgent extends BaseBot {\r\n  /**\r\n   * Handle task assignment event\r\n   */\r\n  handleTaskAssignment(event: {\r\n    taskId: string;\r\n    description: string;\r\n    basePlayground: string;\r\n    baseBranch: string;\r\n    assignedAt: string;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Handle cleanup event\r\n   */\r\n  handleCleanup(event: {\r\n    taskId: string;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Create own git worktree\r\n   */\r\n  createWorktree(params: {\r\n    basePath: string;\r\n    worktreePath: string;\r\n    branch: string;\r\n    commitish: string;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Remove own git worktree\r\n   */\r\n  removeWorktree(params: {\r\n    basePath: string;\r\n    worktreePath: string;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Execute task in isolated workspace\r\n   */\r\n  executeTask(params: {\r\n    taskId: string;\r\n    description: string;\r\n    worktreePath: string;\r\n  }): Promise<{\r\n    success: boolean;\r\n    filesModified: string[];\r\n    filesCreated: string[];\r\n    artifacts: any;\r\n  }>;\r\n}\r\n```\r\n\r\n**Event Subscriptions:**\r\n- `agents.{self-agentId}.tasks.assign` - Task assignments\r\n- `agents.{self-agentId}.tasks.cleanup` - Cleanup requests\r\n\r\n**Event Publications:**\r\n- `agents.{self-agentId}.tasks.completed` - Task completion\r\n- `agents.{self-agentId}.tasks.failed` - Task failure\r\n- `agents.{self-agentId}.file.created` - File creation\r\n- `agents.{self-agentId}.file.modified` - File modification\r\n- `agents.{self-agentId}.file.removed` - File removal\r\n- `agents.{self-agentId}.file.moved` - File move\r\n\r\n**Dependencies:**\r\n- mcp-server-git (via broker with retry via BaseBot)\r\n- mcp-shrimp-task-manager (via broker with retry via BaseBot)\r\n\r\n**Reuses:**\r\n- BaseBot.invokeToolWithRetry() for fault-tolerant tool calls\r\n- BaseBot.checkCircuitBreaker() for failure detection\r\n- BaseBot metrics tracking\r\n\r\n---\r\n\r\n### Component 3: Shadow Agents (shadow-agent-artist, shadow-agent-designer, shadow-agent-programmer)\r\n\r\n**Purpose:** Monitor worker agents and commit/push every file operation to separate remote repositories for rollback capability\r\n\r\n**Implementation:**\r\n- **Files**:\r\n  - `shadow-agent-artist/src/index.ts`\r\n  - `shadow-agent-designer/src/index.ts`\r\n  - `shadow-agent-programmer/src/index.ts`\r\n- **Extends**: BaseBot (for resilience patterns)\r\n- **Networks**:\r\n  - shadow-agent-artist: `['global', 'artist']`\r\n  - shadow-agent-designer: `['global', 'design']`\r\n  - shadow-agent-programmer: `['global', 'programmer']`\r\n\r\n**Interfaces (Internal):**\r\n\r\n```typescript\r\ninterface ShadowAgent extends BaseBot {\r\n  /**\r\n   * Handle file operation event from worker agent\r\n   */\r\n  handleFileOperation(event: {\r\n    operationType: 'created' | 'modified' | 'removed' | 'moved';\r\n    filePath: string;\r\n    oldPath?: string; // For move operations\r\n    taskId: string;\r\n    timestamp: string;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Commit and push file change to shadow repository\r\n   */\r\n  commitAndPush(params: {\r\n    operationType: string;\r\n    filePath: string;\r\n    taskId: string;\r\n  }): Promise<{\r\n    commitHash: string;\r\n    pushed: boolean;\r\n  }>;\r\n\r\n  /**\r\n   * Get shadow repository remote URL\r\n   */\r\n  getShadowRemote(): string;\r\n}\r\n```\r\n\r\n**Event Subscriptions:**\r\n- `agents.{monitored-worker}.file.created`\r\n- `agents.{monitored-worker}.file.modified`\r\n- `agents.{monitored-worker}.file.removed`\r\n- `agents.{monitored-worker}.file.moved`\r\n\r\n**Event Publications:**\r\n- `agents.{self-agentId}.commits.pushed` - After pushing to shadow repo\r\n\r\n**Dependencies:**\r\n- mcp-server-git (via broker with retry via BaseBot)\r\n\r\n**Reuses:**\r\n- BaseBot.invokeToolWithRetry() for git operations\r\n- BaseBot.checkCircuitBreaker() for failure detection\r\n\r\n**Shadow Repository Configuration:**\r\n```\r\nshadow-agent-artist:\r\n  - Local: C:\\p4\\Personal\\SD\\agent-playground-artist (shares with worker)\r\n  - Remote: github.com/user/project-shadow-artist\r\n\r\nshadow-agent-designer:\r\n  - Local: C:\\p4\\Personal\\SD\\agent-playground-designer (shares with worker)\r\n  - Remote: github.com/user/project-shadow-designer\r\n\r\nshadow-agent-programmer:\r\n  - Local: C:\\p4\\Personal\\SD\\agent-playground-programmer (shares with worker)\r\n  - Remote: github.com/user/project-shadow-programmer\r\n```\r\n\r\n---\r\n\r\n## Data Models\r\n\r\n### TaskAssignmentEvent\r\n\r\n```typescript\r\ninterface TaskAssignmentEvent {\r\n  taskId: string;              // Unique task identifier (e.g., \"task-001\")\r\n  description: string;         // Task description from mcp-shrimp-task-manager\r\n  basePlayground: string;      // Base git directory (e.g., \"C:\\p4\\Personal\\SD\\agent-playground\")\r\n  baseBranch: string;          // Branch to base worktree on (e.g., \"main\")\r\n  assignedAt: string;          // ISO 8601 timestamp\r\n  requiredCapabilities?: string[]; // Skills needed (optional)\r\n  estimatedDuration?: string;  // Estimated time (optional)\r\n}\r\n```\r\n\r\n### TaskCompletionEvent\r\n\r\n```typescript\r\ninterface TaskCompletionEvent {\r\n  taskId: string;              // Task identifier\r\n  success: boolean;            // Whether task completed successfully\r\n  completedAt: string;         // ISO 8601 timestamp\r\n  artifacts: {\r\n    apiEndpoints?: Array<{\r\n      method: string;\r\n      path: string;\r\n      purpose: string;\r\n      location: string;\r\n    }>;\r\n    components?: Array<{\r\n      name: string;\r\n      type: string;\r\n      purpose: string;\r\n      location: string;\r\n    }>;\r\n    functions?: Array<{\r\n      name: string;\r\n      signature: string;\r\n      location: string;\r\n    }>;\r\n  };\r\n  filesModified: string[];     // Paths of modified files\r\n  filesCreated: string[];      // Paths of created files\r\n}\r\n```\r\n\r\n### FileOperationEvent\r\n\r\n```typescript\r\ninterface FileOperationEvent {\r\n  operationType: 'created' | 'modified' | 'removed' | 'moved';\r\n  filePath: string;            // Current file path\r\n  oldPath?: string;            // Previous path (for move operations)\r\n  taskId: string;              // Associated task\r\n  timestamp: string;           // ISO 8601 timestamp\r\n  agentId: string;             // Worker agent that performed operation\r\n}\r\n```\r\n\r\n### CleanupEvent\r\n\r\n```typescript\r\ninterface CleanupEvent {\r\n  taskId: string;              // Task identifier\r\n  worktreePath: string;        // Path to worktree to remove\r\n  cleanupReason: 'completed' | 'failed' | 'user_cancelled';\r\n  timestamp: string;           // ISO 8601 timestamp\r\n}\r\n```\r\n\r\n### ProducerState (Internal)\r\n\r\n```typescript\r\ninterface ProducerState {\r\n  activeWorkflows: Map<string, {\r\n    specName: string;\r\n    tasks: Array<{\r\n      taskId: string;\r\n      assignedTo: string;\r\n      status: 'pending' | 'in_progress' | 'completed' | 'failed';\r\n    }>;\r\n    pendingUserApproval: boolean;\r\n    createdAt: string;\r\n  }>;\r\n  channelContexts: Map<string, {\r\n    channelType: 'slack' | 'discord' | 'claude-code' | 'claude-desktop';\r\n    channelId: string;\r\n    userId: string;\r\n    lastInteraction: string;\r\n  }>;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n#### Scenario 1: Worker Agent Failure During Task Execution\r\n\r\n**Description:** Worker agent encounters unhandled exception or crashes during task execution\r\n\r\n**Handling:**\r\n1. Worker agent's circuit breaker opens after 5 consecutive failures\r\n2. Worker publishes `agents.{agentId}.tasks.failed` event\r\n3. agent-producer receives failure event\r\n4. agent-producer logs failure to mcp-shrimp-task-manager\r\n5. agent-producer attempts reassignment:\r\n   - If < 3 retries: reassigns to same agent after circuit breaker reset (60s)\r\n   - If >= 3 retries: marks task as failed, notifies user\r\n\r\n**User Impact:**\r\n- **Slack/Discord**: Receives error message: \"Task task-001 failed after 3 attempts. Please review error logs.\"\r\n- **Claude Code/Desktop**: `get_task_status(taskId)` returns status: \"failed\" with error details\r\n\r\n#### Scenario 2: Git Worktree Creation Conflict\r\n\r\n**Description:** Worker agent attempts to create worktree but path already exists\r\n\r\n**Handling:**\r\n1. Worker calls `git__worktree` with mode 'add'\r\n2. Git returns error: \"worktree already exists\"\r\n3. Worker's retry logic attempts 3 times with exponential backoff\r\n4. If still failing after retries:\r\n   - Worker attempts cleanup: `git__worktree` mode 'remove' with force=true\r\n   - Retries creation after cleanup\r\n5. If cleanup fails: publishes task failure event\r\n\r\n**User Impact:**\r\n- Usually transparent (automatic recovery)\r\n- If persistent: \"Could not allocate workspace for task. Manual cleanup required at C:\\p4\\Personal\\SD\\agent-playground-artist\"\r\n\r\n#### Scenario 3: Shadow Agent Push Failure\r\n\r\n**Description:** Shadow agent cannot push to remote repository (network/auth issues)\r\n\r\n**Handling:**\r\n1. Shadow agent calls `git__push` via BaseBot.invokeToolWithRetry()\r\n2. Retry logic attempts 3 times (1s, 2s, 4s delays)\r\n3. If all retries fail:\r\n   - Shadow agent logs error locally\r\n   - Publishes `agents.{shadow-agentId}.push.failed` event\r\n   - Continues monitoring (doesn't block worker agent)\r\n4. Queues failed push for later retry (exponential backoff up to 10 minutes)\r\n\r\n**User Impact:**\r\n- Worker agent continues uninterrupted (shadow failure doesn't block)\r\n- Rollback capability temporarily degraded\r\n- User notified: \"Shadow versioning temporarily unavailable for agent-artist. Work continues but rollback limited.\"\r\n\r\n#### Scenario 4: User Approves Empty Completion\r\n\r\n**Description:** User calls `approve_completion()` when no tasks are completed\r\n\r\n**Handling:**\r\n1. agent-producer checks ProducerState.activeWorkflows\r\n2. Finds no workflows with pendingUserApproval=true\r\n3. Returns structured response:\r\n   ```json\r\n   {\r\n     \"status\": \"no_pending_work\",\r\n     \"message\": \"No completed tasks pending approval\"\r\n   }\r\n   ```\r\n\r\n**User Impact:**\r\n- **Claude Code/Desktop**: Receives clear JSON response\r\n- **Slack/Discord**: Receives message: \"No completed tasks to approve. Current active tasks: 3 in progress.\"\r\n\r\n#### Scenario 5: MCP Upstream Server Unavailable\r\n\r\n**Description:** mcp-shrimp-task-manager or mcp-server-git is not responding\r\n\r\n**Handling:**\r\n1. agent-producer/worker calls tool via protocol.invokeTool()\r\n2. BaseBot.invokeToolWithRetry() handles failure:\r\n   - Attempts 3 retries with exponential backoff\r\n   - Circuit breaker opens after 5 consecutive failures\r\n3. If circuit open: returns error immediately without retry\r\n4. If max retries exceeded: throws error with context\r\n\r\n**User Impact:**\r\n- **Slack/Discord**: \"Task planning service temporarily unavailable. Please try again in 1 minute.\"\r\n- **Claude Code/Desktop**: Tool call returns error object:\r\n  ```json\r\n  {\r\n    \"error\": \"Service unavailable\",\r\n    \"retryAfter\": 60,\r\n    \"message\": \"mcp-shrimp-task-manager not responding\"\r\n  }\r\n  ```\r\n\r\n#### Scenario 6: Invalid Task Assignment (Worker Capacity)\r\n\r\n**Description:** agent-producer assigns task to worker already processing maximum tasks\r\n\r\n**Handling:**\r\n1. Worker maintains internal task queue (max 3 concurrent tasks)\r\n2. If queue full: worker publishes `agents.{agentId}.capacity.exceeded` event\r\n3. agent-producer receives capacity event\r\n4. agent-producer queues task for later assignment\r\n5. Retries assignment when worker publishes completion event\r\n\r\n**User Impact:**\r\n- Transparent queue management\r\n- Slightly delayed task start: \"Task queued for agent-artist (currently processing 3/3 tasks)\"\r\n\r\n---\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**BaseBot Resilience Patterns:**\r\n- Circuit breaker behavior (open after 5 failures, reset after 60s)\r\n- Retry logic with exponential backoff (1s, 2s, 4s)\r\n- Metrics tracking accuracy\r\n\r\n**Worker Agent Worktree Management:**\r\n- Git worktree creation via mcp-server-git\r\n- Git worktree cleanup after completion\r\n- Conflict resolution when path already exists\r\n\r\n**Shadow Agent Monitoring:**\r\n- File event subscription and handling\r\n- Git commit creation with correct messages\r\n- Git push to shadow remote repositories\r\n\r\n**agent-producer MCP Tools:**\r\n- `plan_task` input validation and workflow initiation\r\n- `list_active_tasks` state querying\r\n- `get_task_status` task lookup\r\n- `approve_completion` workflow validation and git push\r\n\r\n### Integration Testing\r\n\r\n**End-to-End Workflow (Event-Driven Channel):**\r\n1. Simulate Slack mention event via mcp-client-slack\r\n2. Verify agent-producer receives and processes event\r\n3. Verify task planning via mcp-shrimp-task-manager\r\n4. Verify task assignment events published\r\n5. Verify worker agent receives and creates worktree\r\n6. Verify worker agent executes task and publishes completion\r\n7. Verify shadow agent monitors and commits changes\r\n8. Verify agent-producer requests user approval via Slack\r\n9. Verify git push to main repo after approval\r\n10. Verify cleanup events and worktree removal\r\n\r\n**End-to-End Workflow (Tool-Based Channel):**\r\n1. Simulate `plan_task` tool call from Claude Code\r\n2. Verify agent-producer processes and returns structured result\r\n3. Verify task planning and assignment\r\n4. Poll `list_active_tasks` during execution\r\n5. Call `get_task_status` for specific task\r\n6. Call `approve_completion` after all tasks done\r\n7. Verify git push and cleanup\r\n\r\n**Failure Recovery:**\r\n- Worker agent crash during task execution → reassignment\r\n- Git push failure → retry logic and circuit breaker\r\n- Shadow agent unavailable → worker continues uninterrupted\r\n\r\n### End-to-End Testing\r\n\r\n**Scenario 1: Multi-Agent Collaboration (Slack)**\r\n- User requests: \"Create a todo app with React frontend and Express backend\"\r\n- Verify task distribution: agent-designer (docs), agent-programmer (backend), agent-artist (UI assets)\r\n- Verify concurrent execution in separate worktrees\r\n- Verify shadow agents track all changes independently\r\n- Verify user approval flow in Slack\r\n- Verify main repo merge and cleanup\r\n\r\n**Scenario 2: Real-Time Progress Monitoring (Claude Code)**\r\n- User calls `plan_task` with complex request\r\n- Poll `list_active_tasks` every 10 seconds\r\n- Verify progress updates reflect actual task execution\r\n- Call `get_task_status` for detailed info\r\n- Approve with `approve_completion` tool\r\n- Verify structured responses throughout\r\n\r\n**Scenario 3: Rollback After User Rejection**\r\n- Complete tasks across multiple workers\r\n- Shadow agents version all changes\r\n- User rejects changes (simulated)\r\n- Verify main repo unchanged\r\n- Verify shadow repos contain complete history\r\n- Verify ability to cherry-pick changes from shadow repos\r\n\r\n**Scenario 4: Concurrent Multi-User Requests**\r\n- Multiple users submit requests via different channels simultaneously\r\n- Verify agent-producer maintains separate workflow contexts\r\n- Verify no cross-contamination between workflows\r\n- Verify correct channel routing for responses\r\n\r\n---\r\n\r\n## Implementation Notes\r\n\r\n### MCP Upstream Registration for agent-producer\r\n\r\n**Location:** `kadi-broker/config/mcp-upstreams.json`\r\n\r\n**Configuration:**\r\n```json\r\n{\r\n  \"upstreams\": [\r\n    {\r\n      \"id\": \"agent-producer\",\r\n      \"name\": \"agent-producer\",\r\n      \"description\": \"Multi-agent orchestration with task planning and approval workflow\",\r\n      \"type\": \"stdio\",\r\n      \"prefix\": \"producer\",\r\n      \"enabled\": true,\r\n      \"stdio\": {\r\n        \"command\": \"node\",\r\n        \"args\": [\"C:\\\\p4\\\\Personal\\\\SD\\\\AGENTS\\\\agent-producer\\\\dist\\\\index.js\"],\r\n        \"env\": {\r\n          \"NODE_ENV\": \"production\",\r\n          \"ENABLE_MCP_TOOLS\": \"true\"\r\n        }\r\n      },\r\n      \"networks\": [\"global\"],\r\n      \"retryPolicy\": {\r\n        \"maxAttempts\": 3,\r\n        \"initialBackoffMs\": 1000,\r\n        \"maxBackoffMs\": 10000,\r\n        \"backoffMultiplier\": 2\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### Git Worktree Paths\r\n\r\n**Base Directory:** `C:\\p4\\Personal\\SD\\agent-playground`\r\n\r\n**Worker Worktrees (created by workers):**\r\n- `C:\\p4\\Personal\\SD\\agent-playground-artist`\r\n- `C:\\p4\\Personal\\SD\\agent-playground-designer`\r\n- `C:\\p4\\Personal\\SD\\agent-playground-programmer`\r\n\r\n**Git Remote Repositories:**\r\n- **Main repo**: agent-producer pushes after user approval\r\n- **Shadow repos**: 3 separate repositories (one per shadow agent)\r\n  - `github.com/user/project-shadow-artist`\r\n  - `github.com/user/project-shadow-designer`\r\n  - `github.com/user/project-shadow-programmer`\r\n\r\n### Network Assignments\r\n\r\n| Agent | Networks | Purpose |\r\n|-------|----------|---------|\r\n| agent-producer | global, git, slack, discord | Access to all services |\r\n| agent-artist | global, artist | Isolated artist domain |\r\n| agent-designer | global, design | Isolated design domain |\r\n| agent-programmer | global, programmer | Isolated programmer domain |\r\n| shadow-agent-artist | global, artist | Monitor artist |\r\n| shadow-agent-designer | global, design | Monitor designer |\r\n| shadow-agent-programmer | global, programmer | Monitor programmer |\r\n| mcp-shrimp-task-manager | global | Task management |\r\n| mcp-server-git | global, git | Git operations |\r\n| mcp-client-slack | global, slack | Slack integration |\r\n| mcp-client-discord | global, discord | Discord integration |\r\n\r\n---\r\n\r\n## Performance Considerations\r\n\r\n1. **Concurrent Task Execution**\r\n   - Git worktrees enable true parallel execution\r\n   - No file conflicts between workers\r\n   - Shadow agents operate asynchronously (no blocking)\r\n\r\n2. **Event vs Tool Performance**\r\n   - Event-driven (Slack/Discord): Lower latency, higher throughput\r\n   - Tool-based (Claude Code/Desktop): Synchronous, user-initiated\r\n\r\n3. **Circuit Breaker Benefits**\r\n   - Prevents cascade failures\r\n   - Fast-fail when services unavailable\r\n   - Automatic recovery after cooldown\r\n\r\n4. **Shadow Agent Overhead**\r\n   - Minimal impact on worker performance (async commits)\r\n   - Network bandwidth for git push to shadow remotes\r\n   - Storage for duplicate repositories (worth it for rollback capability)\r\n\r\n",
  "fileStats": {
    "size": 35110,
    "lines": 1072,
    "lastModified": "2025-11-30T12:02:26.710Z"
  },
  "comments": []
}